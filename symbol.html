<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Analyze individual stock symbols with charts, quote data, and community discussion tools.">
    <meta name="robots" content="index,follow,max-image-preview:large">
    <link rel="canonical" href="https://si-tip.com/symbol.html">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Symbol Board - Smart Investment Tips">
    <meta property="og:description" content="Analyze individual stock symbols with charts, quote data, and community discussion tools.">
    <meta property="og:url" content="https://si-tip.com/symbol.html">
    <meta property="og:site_name" content="Smart Investment Tips">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Symbol Board - Smart Investment Tips">
    <meta name="twitter:description" content="Analyze individual stock symbols with charts, quote data, and community discussion tools.">
    <title>Symbol Board - Smart Investment Tips</title>
    <style>
        :root {
            --navy: #0e2a47;
            --navy2: #1f4f82;
            --ink: #0f172a;
            --muted: #64748b;
            --panel: #ffffff;
            --bg: #ffffff;
            --accent: #1f4f82;
            --accent-soft: #e8eef6;
            --line: #e2e8f0;
            --shadow: 0 14px 30px rgba(15, 23, 42, 0.08);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", sans-serif;
            background: radial-gradient(circle at top, #f8fbff, #ffffff 62%);
            color: var(--ink);
            line-height: 1.6;
        }

        nav {
            background: var(--panel);
            box-shadow: 0 4px 14px rgba(15, 23, 42, 0.06);
            border-bottom: 1px solid var(--line);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        nav .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        nav .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--navy);
        }

        nav a {
            text-decoration: none;
            color: #334155;
            font-weight: 600;
            margin-left: 16px;
        }

        nav a:hover { color: var(--accent); }

        .hero {
            max-width: 1200px;
            margin: 30px auto 0;
            padding: 0 20px;
        }

        .hero-card {
            background: linear-gradient(135deg, var(--navy), var(--navy2));
            color: #fff;
            border-radius: 18px;
            padding: 30px;
            box-shadow: var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .hero-card h1 {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .hero-card p { opacity: 0.9; }

        .content {
            max-width: 1200px;
            margin: 24px auto 80px;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 240px minmax(0, 1fr) 360px;
            gap: 20px;
        }

        .panel {
            background: var(--panel);
            border-radius: 16px;
            padding: 22px;
            box-shadow: 0 8px 22px rgba(15, 23, 42, 0.06);
            border: 1px solid var(--line);
        }

        .panel h2 {
            font-size: 20px;
            margin-bottom: 6px;
            color: var(--navy);
        }

        .panel p.desc {
            color: var(--muted);
            font-size: 14px;
            margin-bottom: 14px;
        }

        .row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 12px;
        }

        label {
            display: block;
            font-size: 13px;
            color: var(--muted);
            margin-bottom: 6px;
        }

        input, textarea, button {
            width: 100%;
            border-radius: 10px;
            border: 1px solid var(--line);
            padding: 10px 12px;
            font-size: 14px;
            font-family: inherit;
            background: #fff;
        }

        textarea { min-height: 110px; resize: vertical; }

        button.primary {
            background: var(--navy);
            color: #fff;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button.primary:hover { background: var(--navy2); }

        button.ghost {
            background: transparent;
            border: 1px solid var(--line);
            color: var(--ink);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button.ghost:hover { background: #f8fafc; }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        #categoryTabs {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .tab {
            width: 100%;
            padding: 8px 14px;
            border-radius: 10px;
            border: 1px solid var(--line);
            background: #fff;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: var(--muted);
            text-align: left;
        }

        .tab.active {
            background: var(--accent-soft);
            color: var(--accent);
            border-color: #bfdbfe;
        }

        .post-list {
            display: grid;
            gap: 12px;
        }

        .post {
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 14px;
            background: #fff;
        }

        .post h3 {
            font-size: 16px;
            margin-bottom: 6px;
        }

        .meta {
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 8px;
        }

        .actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .helper {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px;
        }

        .chart-wrap {
            border: 1px solid var(--line);
            border-radius: 14px;
            overflow: hidden;
            background: #f8fafc;
        }

        #lightweightChart {
            width: 100%;
            height: 340px;
            background: #fff;
        }

        #volumeChart {
            width: 100%;
            height: 78px;
            background: #fff;
        }

        .chart-meta {
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px;
        }

        .indicator-toolbar {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid var(--line);
            border-radius: 10px;
            background: #f8fafc;
            display: grid;
            gap: 8px;
        }

        .frame-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .frame-btn {
            width: auto;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 12px;
            background: #fff;
            border: 1px solid var(--line);
            color: var(--muted);
            cursor: pointer;
        }

        .frame-btn.active {
            background: var(--accent-soft);
            border-color: #bfdbfe;
            color: var(--accent);
            font-weight: 700;
        }

        .indicator-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 6px;
        }

        .indicator-settings {
            margin-top: 8px;
            padding: 8px;
            border: 1px solid var(--line);
            border-radius: 10px;
            background: #fff;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 8px;
        }

        .indicator-settings label {
            margin-bottom: 4px;
            font-size: 11px;
        }

        .indicator-settings input {
            padding: 8px 10px;
            font-size: 12px;
        }

        .indicator-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--ink);
        }

        .indicator-item input {
            width: auto;
            margin: 0;
            padding: 0;
        }

        .indicator-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 6px;
            margin-top: 10px;
        }

        .indicator-subcharts {
            display: grid;
            gap: 8px;
            margin-top: 10px;
        }

        .subchart-box {
            border: 1px solid var(--line);
            border-radius: 10px;
            background: #fff;
            overflow: hidden;
        }

        .subchart-title {
            font-size: 12px;
            color: var(--muted);
            padding: 6px 10px;
            border-bottom: 1px solid var(--line);
            background: #f8fafc;
        }

        .subchart-canvas {
            width: 100%;
            height: 96px;
        }

        .indicator-value-card {
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 6px;
            background: #fff;
        }

        .indicator-value-card .name {
            font-size: 11px;
            color: var(--muted);
        }

        .indicator-value-card .val {
            font-size: 12px;
            font-weight: 700;
        }

        .chat-wrap {
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 10px;
            background: #fff;
            margin-bottom: 10px;
        }

        .chat-messages {
            max-height: 220px;
            overflow-y: auto;
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 8px;
            background: #f8fafc;
            display: grid;
            gap: 6px;
        }

        .chat-item {
            border: 1px solid var(--line);
            border-radius: 8px;
            background: #fff;
            padding: 6px 8px;
        }

        .chat-meta {
            font-size: 11px;
            color: var(--muted);
            margin-bottom: 2px;
        }

        .chat-form {
            margin-top: 8px;
            display: grid;
            grid-template-columns: 1fr 110px;
            gap: 8px;
        }

        .sim-grid-mini {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .sim-box {
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 10px;
            background: #fff;
        }

        .sim-value {
            font-size: 20px;
            font-weight: 700;
        }

        .sim-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .prop-rule-box {
            margin-top: 12px;
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 12px;
            background: #f8fafc;
        }

        .prop-rule-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .prop-rule-presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .prop-preset-btn {
            border: 1px solid var(--line);
            border-radius: 999px;
            background: #fff;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
        }

        .prop-preset-btn.active {
            background: #2563eb;
            border-color: #2563eb;
            color: #fff;
        }

        .prop-rule-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
            margin-top: 8px;
        }

        .prop-rule-status {
            margin-top: 8px;
            font-size: 12px;
            color: var(--muted);
        }

        .sim-table-wrap {
            overflow: auto;
            max-height: 220px;
            border: 1px solid var(--line);
            border-radius: 10px;
            margin-top: 10px;
        }

        .sim-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .sim-table th,
        .sim-table td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid var(--line);
        }

        .positive { color: #16a34a; }
        .negative { color: #dc2626; }

        #symbolPanel {
            grid-column: 1 / -1;
        }

        #chartPanel { order: 1; }
        #chartPanel { grid-column: 2; }
        #simulatorPanel { order: 2; grid-column: 3; align-self: start; }
        #categoryPanel { order: 3; grid-column: 1; }
        #writePanel { order: 4; grid-column: 2 / -1; }
        #postsPanel { order: 5; grid-column: 2 / -1; }
        #symbolPanel { order: 6; }

        @media (max-width: 1180px) {
            .content {
                grid-template-columns: 240px 1fr;
            }
            #chartPanel,
            #simulatorPanel,
            #writePanel,
            #postsPanel {
                grid-column: 2;
            }
        }

        @media (max-width: 720px) {
            nav .container { padding: 1rem; }
            .hero-card { padding: 22px; }
            .content {
                grid-template-columns: 1fr;
            }
            #chartPanel,
            #simulatorPanel,
            #categoryPanel,
            #writePanel,
            #postsPanel,
            #symbolPanel {
                grid-column: 1;
            }
        }
    </style>
<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "vmylxac7pb");
</script>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg?v=3">
    <link rel="shortcut icon" href="/favicon.ico?v=3">
</head>
<body>
    <nav>
        <div class="container">
            <div class="logo">Smart Investment Tips</div>
            <div>
                <a href="./index.html">Home</a>
                <a href="./market.html">Markets</a>
                <a href="./journal.html">Journal</a>
                <a href="./prop.html">Prop</a>
                <a href="./advertise.html">Advertise</a>
                <a href="./contact.html">Contact</a>
                <a href="./auth.html">Login</a>
            </div>
        </div>
    </nav>

    <section class="hero">
        <div class="hero-card">
            <h1 id="boardTitle">Symbol Board</h1>
            <p>You can write posts for each symbol in Trading Journal and Free Board categories. All posts are stored in your browser.</p>
        </div>
    </section>

    <section class="content">
        <div class="panel" id="symbolPanel">
            <h2>Select Symbol</h2>
            <p class="desc">Enter a symbol to open its board.</p>
            <div class="row">
                <div>
                    <label for="symbolInput">Symbol/Ticker</label>
                    <input id="symbolInput" type="text" placeholder="AAPL, 005930" />
                </div>
                <div>
                    <label>&nbsp;</label>
                    <button class="primary" id="goSymbol">Open Board</button>
                </div>
            </div>
            <div class="helper">Example: AAPL, TSLA, 005930</div>
        </div>

        <div class="panel" id="categoryPanel">
            <h2>Category</h2>
            <p class="desc">Choose a category to write or view posts.</p>
            <div class="tabs" id="categoryTabs"></div>
            <div class="helper">Categories: Trading Journal · Free Board</div>
        </div>

        <div class="panel" id="chartPanel">
            <h2 id="chartTitle">AAPL Chart</h2>
            <p class="desc">The chart updates automatically when the symbol changes. Review price flow before posting journal notes.</p>

            <div class="chart-wrap">
                <div id="lightweightChart"></div>
            </div>
            <div class="chart-wrap" style="margin-top:8px;">
                <div id="volumeChart"></div>
            </div>
            <div class="chart-meta" id="lightweightSource">This educational chart is delayed by approximately 15 minutes. Source: Lightweight Charts by TradingView.</div>
            <div class="chart-meta" id="chartStatusMessage"></div>

            <div class="indicator-toolbar">
                <div class="frame-toolbar" id="frameToolbar"></div>
                <div class="helper" style="margin-top:0;">Expanded indicators: configurable MA/EMA/WMA · VWAP · Bollinger · RSI · MACD · Stochastic · ATR · ROC · CCI · Volume</div>
                <div class="indicator-list" id="indicatorToggleList"></div>
                <div class="indicator-settings" id="indicatorSettingsPanel">
                    <div>
                        <label for="maFastPeriodInput">MA Fast</label>
                        <input id="maFastPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="maMidPeriodInput">MA Mid</label>
                        <input id="maMidPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="maSlowPeriodInput">MA Slow</label>
                        <input id="maSlowPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="emaFastPeriodInput">EMA Fast</label>
                        <input id="emaFastPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="emaSlowPeriodInput">EMA Slow</label>
                        <input id="emaSlowPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="wmaPeriodInput">WMA</label>
                        <input id="wmaPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="bbPeriodInput">Bollinger</label>
                        <input id="bbPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="rsiPeriodInput">RSI</label>
                        <input id="rsiPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="macdFastPeriodInput">MACD Fast</label>
                        <input id="macdFastPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="macdSlowPeriodInput">MACD Slow</label>
                        <input id="macdSlowPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="macdSignalPeriodInput">MACD Signal</label>
                        <input id="macdSignalPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="stochPeriodInput">Stoch %K</label>
                        <input id="stochPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="stochSmoothInput">Stoch %D</label>
                        <input id="stochSmoothInput" type="number" min="1" max="100" step="1" />
                    </div>
                    <div>
                        <label for="atrPeriodInput">ATR</label>
                        <input id="atrPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="rocPeriodInput">ROC</label>
                        <input id="rocPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="cciPeriodInput">CCI</label>
                        <input id="cciPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                    <div>
                        <label for="volumeMaPeriodInput">Volume MA</label>
                        <input id="volumeMaPeriodInput" type="number" min="2" max="300" step="1" />
                    </div>
                </div>
            </div>
            <div class="indicator-values" id="indicatorValueBoard"></div>
            <div class="indicator-subcharts" id="indicatorSubcharts">
                <div class="subchart-box">
                    <div class="subchart-title">RSI (14)</div>
                    <div id="rsiChart" class="subchart-canvas"></div>
                </div>
                <div class="subchart-box">
                    <div class="subchart-title">MACD (12, 26, 9)</div>
                    <div id="macdChart" class="subchart-canvas"></div>
                </div>
                <div class="subchart-box">
                    <div class="subchart-title">Stochastic (14, 3)</div>
                    <div id="stochChart" class="subchart-canvas"></div>
                </div>
            </div>

        </div>

        <div class="panel" id="simulatorPanel">
            <h2>Virtual Trading Simulator</h2>
            <p class="desc">You can run instant virtual trades on the current chart symbol, without moving to a separate simulator page.</p>

            <div class="sim-grid-mini">
                <div class="sim-box">
                    <div class="helper">Cash Balance</div>
                    <div class="sim-value" id="simCashDisplay">$100,000.00</div>
                </div>
                <div class="sim-box">
                    <div class="helper">Total Portfolio Value</div>
                    <div class="sim-value" id="simPortfolioDisplay">$100,000.00</div>
                </div>
                <div class="sim-box">
                    <div class="helper">Current Price (Selected Symbol)</div>
                    <div class="sim-value" id="simCurrentPriceDisplay">$0.00</div>
                </div>
                <div class="sim-box">
                    <div class="helper">Position P/L (+/-)</div>
                    <div class="sim-value" id="simPositionPnLDisplay">$0.00 (0.00%)</div>
                </div>
            </div>

            <div class="row">
                <div>
                    <label for="simQtyInput">Quantity</label>
                    <input id="simQtyInput" type="number" min="1" placeholder="Qty" />
                </div>
                <div>
                    <label for="simLimitInput">Limit Price</label>
                    <input id="simLimitInput" type="number" min="0.01" step="0.01" placeholder="Limit Price" />
                </div>
            </div>

            <div class="sim-controls">
                <button id="simMarketBuyBtn" class="primary" type="button">Market Buy</button>
                <button id="simMarketSellBtn" class="ghost" type="button">Market Sell</button>
                <button id="simLimitBuyBtn" class="primary" type="button">Limit Buy</button>
                <button id="simLimitSellBtn" class="ghost" type="button">Limit Sell</button>
                <button id="simCloseAllBtn" class="ghost" type="button">Close All Positions</button>
            </div>
            <div class="helper" id="simTradeHint">Orders execute for the currently selected symbol. Sell orders can open short positions.</div>

            <div class="prop-rule-box" id="propRulePanel">
                <div class="prop-rule-head">
                    <strong style="font-size:14px;">Prop Rule Settings (Members Only)</strong>
                    <div class="prop-rule-presets">
                        <button id="propPresetCustomBtn" class="prop-preset-btn active" type="button">Custom</button>
                        <button id="propPresetEodBtn" class="prop-preset-btn" type="button">EOD MDD</button>
                        <button id="propPresetTmddBtn" class="prop-preset-btn" type="button">TMDD</button>
                    </div>
                </div>

                <div class="prop-rule-grid">
                    <div>
                        <label for="propAccountSize">Virtual Account</label>
                        <select id="propAccountSize">
                            <option value="25000">25,000</option>
                            <option value="50000">50,000</option>
                            <option value="100000" selected>100,000</option>
                        </select>
                    </div>
                    <div>
                        <label for="propDailyLossPct">Daily Loss Limit (%)</label>
                        <input id="propDailyLossPct" type="number" min="0.1" max="50" step="0.1" value="5" />
                    </div>
                    <div>
                        <label for="propMaxDrawdownPct">Max Drawdown Limit (%)</label>
                        <input id="propMaxDrawdownPct" type="number" min="0.1" max="90" step="0.1" value="10" />
                    </div>
                    <div>
                        <label for="propConsistencyPct">Consistency Cap (% of equity per order)</label>
                        <input id="propConsistencyPct" type="number" min="1" max="100" step="1" value="35" />
                    </div>
                    <div>
                        <label for="propMaxTradesPerDay">Max Trades per Day</label>
                        <input id="propMaxTradesPerDay" type="number" min="1" max="500" step="1" value="30" />
                    </div>
                    <div>
                        <label for="propMaxOpenPositions">Max Open Positions</label>
                        <input id="propMaxOpenPositions" type="number" min="1" max="100" step="1" value="5" />
                    </div>
                    <div>
                        <label for="propMaxQtyPerOrder">Max Qty per Order</label>
                        <input id="propMaxQtyPerOrder" type="number" min="1" max="1000000" step="1" value="500" />
                    </div>
                    <div>
                        <label for="propMaxPositionPct">Max Position Notional (% of equity)</label>
                        <input id="propMaxPositionPct" type="number" min="1" max="100" step="1" value="60" />
                    </div>
                </div>

                <div class="actions" style="margin-top:8px;">
                    <button id="propApplyRulesBtn" class="primary" type="button">Apply Rules</button>
                    <button id="propResetAccountBtn" class="ghost" type="button">Reset Account</button>
                    <button id="propSavePresetBtn" class="ghost" type="button">Save Current to Preset</button>
                </div>
                <div class="helper" id="propRuleMemberNote">Login required to change prop rules.</div>
                <div class="prop-rule-status" id="propRuleStatus"></div>
                <div class="helper negative" id="propRuleFailBadge" style="display:none; margin-top:6px; font-weight:700;"></div>
            </div>

            <h3 style="margin-top:14px; font-size:16px;">Holdings</h3>
            <div class="sim-table-wrap">
                <table class="sim-table">
                    <thead><tr><th>Symbol</th><th>Qty</th><th>Avg</th><th>Current</th><th>P/L</th></tr></thead>
                    <tbody id="simHoldingsBody"></tbody>
                </table>
            </div>

            <h3 style="margin-top:14px; font-size:16px;">Trade History</h3>
            <div class="sim-table-wrap">
                <table class="sim-table">
                    <thead><tr><th>Date</th><th>Symbol</th><th>Side</th><th>Qty</th><th>Price</th></tr></thead>
                    <tbody id="simTxBody"></tbody>
                </table>
            </div>
        </div>

        <div class="panel" id="writePanel">
            <h2>Write a New Post</h2>
            <p class="desc">Posts are saved under the selected category.</p>
            <form id="postForm">
                <div class="row">
                    <div>
                        <label for="postTitle">Title</label>
                        <input id="postTitle" type="text" required />
                    </div>
                    <div>
                        <label for="postAuthor">Nickname</label>
                        <input id="postAuthor" type="text" placeholder="Anonymous" />
                    </div>
                </div>
                <div>
                    <label for="postBody">Content</label>
                    <textarea id="postBody" required placeholder="Write freely"></textarea>
                </div>
                <div class="actions">
                    <button class="primary" type="submit">Save Post</button>
                    <button class="ghost" type="button" id="exportPosts">Export</button>
                    <button class="ghost" type="button" id="importPosts">Import</button>
                    <input id="postImportFile" type="file" accept="application/json" style="display:none" />
                </div>
                <div class="helper">Free Board policy: no personal ads, contact-channel solicitation, or sexual content. Repeated violations may lead to posting restrictions (ban). <a href="./community-rules.html" target="_blank" rel="noopener">View policy</a></div>
                <div class="helper">Stored only in your browser. Not shared across devices.</div>
            </form>
        </div>

        <div class="panel" id="postsPanel">
            <h2>Posts</h2>
            <p class="desc" id="postCount">0 posts</p>
            <div class="post-list" id="postList"></div>
        </div>

        <div class="panel" id="disqusPanel">
            <h2>Public Live Chat &amp; Disqus Discussion</h2>
            <p class="desc">공개 실시간 채팅(전체 공유) + 심볼별 Disqus 댓글</p>
            <div class="chat-wrap">
                <div id="liveChatStatus" class="helper">Public live chat is connecting...</div>
                <div id="liveChatMessages" class="chat-messages"></div>
                <div class="chat-form">
                    <input id="liveChatInput" type="text" maxlength="300" placeholder="메시지를 입력하세요 (최대 300자)" />
                    <button id="liveChatSendBtn" class="primary" type="button">Send</button>
                </div>
            </div>
            <div id="disqusThreadStatus" class="helper">Disqus is loading...</div>
            <div id="disqus_thread"></div>
        </div>
    </section>

    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        const CATEGORIES = ['Trading Journal', 'Free Board'];
        const STORAGE_KEY = 'symbol_posts_v1';
        const READ_RESET_REQUEST_KEY = 'prop_read_reset_request_v1';
        const RESET_CLICK_COUNT_KEY = 'prop_reset_click_count_v1';
        const RESET_AD_GRANT_KEY = 'prop_reset_ad_grant_v1';
        const DISQUS_SHORTNAME_KEY = 'disqus_shortname_v1';
        const DISQUS_SHORTNAME_DEFAULT = 'chan-8';
        const INDICATOR_SETTINGS_KEY = 'symbol_indicator_settings_v1';
        const SUPABASE_URL_KEY = 'supabase_url';
        const SUPABASE_ANON_KEY = 'supabase_anon_key';
        const LIVE_CHAT_HISTORY_KEY = 'public_live_chat_history_v1';
        const LIVE_CHAT_HISTORY_MAX = 50;

        const boardTitle = document.getElementById('boardTitle');
        const symbolInput = document.getElementById('symbolInput');
        const goSymbol = document.getElementById('goSymbol');
        const categoryTabs = document.getElementById('categoryTabs');
        const postForm = document.getElementById('postForm');
        const postList = document.getElementById('postList');
        const postCount = document.getElementById('postCount');
        const SIM_INITIAL_CASH = 100000;
        const PROP_RULES_DEFAULT = {
            mode: 'custom',
            startingBalance: 100000,
            dailyLossPct: 5,
            maxDrawdownPct: 10,
            consistencyPct: 35,
            maxTradesPerDay: 30,
            maxOpenPositions: 5,
            maxQtyPerOrder: 500,
            maxPositionPct: 60
        };
        const PROP_PRESETS_DEFAULT = {
            custom: { ...PROP_RULES_DEFAULT, mode: 'custom' },
            eod: {
                ...PROP_RULES_DEFAULT,
                mode: 'eod',
                dailyLossPct: 5,
                maxDrawdownPct: 10,
                consistencyPct: 35,
                maxTradesPerDay: 30,
                maxOpenPositions: 5,
                maxQtyPerOrder: 500,
                maxPositionPct: 60
            },
            tmdd: {
                ...PROP_RULES_DEFAULT,
                mode: 'tmdd',
                dailyLossPct: 5,
                maxDrawdownPct: 6,
                consistencyPct: 35,
                maxTradesPerDay: 20,
                maxOpenPositions: 4,
                maxQtyPerOrder: 300,
                maxPositionPct: 45
            }
        };
        const MODERATION_STATE_KEY = 'community_moderation_state_v1';
        const MODERATION_MAX_STRIKES = 3;
        const MODERATION_BAN_MS = 24 * 60 * 60 * 1000;

        let currentSymbol = 'AAPL';
        let currentCategory = CATEGORIES[0];
        let posts = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        let lwChart;
        let lwSeries;
        let lwSeriesType = 'area';
        let lwEntryLine = null;
        let lwTradeMarkers = [];
        let lwMainData = [];
        let volumeChart;
        let volumeHistSeries;
        let volumeMaSeries;
        let indicatorSeriesMap = {};
        let rsiChart;
        let macdChart;
        let stochChart;
        let rsiSeries;
        let rsiMidSeries;
        let macdLineSeries;
        let macdSignalSeries;
        let macdHistSeries;
        let stochKSeries;
        let stochDSeries;
        let stochMidSeries;
        let realtimeQuoteTimer = null;
        let realtimeRefreshInFlight = false;
        let simBaseCash = SIM_INITIAL_CASH;
        let simCash = SIM_INITIAL_CASH;
        let simPortfolio = {};
        let simTxs = [];
        let propRules = { ...PROP_RULES_DEFAULT };
        let propPresetConfigs = {
            custom: { ...PROP_PRESETS_DEFAULT.custom },
            eod: { ...PROP_PRESETS_DEFAULT.eod },
            tmdd: { ...PROP_PRESETS_DEFAULT.tmdd }
        };
        let propRuleDay = '';
        let propDailyStartEquity = SIM_INITIAL_CASH;
        let propPeakEquity = SIM_INITIAL_CASH;
        let propAccountFailedReason = '';

        const FRAME_OPTIONS = [
            { key: '1D', label: '1D', range: '1d', interval: '5m' },
            { key: '5D', label: '5D', range: '5d', interval: '15m' },
            { key: '1M', label: '1M', range: '1mo', interval: '1h' },
            { key: '3M', label: '3M', range: '3mo', interval: '1d' },
            { key: '6M', label: '6M', range: '6mo', interval: '1d' },
            { key: '1Y', label: '1Y', range: '1y', interval: '1wk' }
        ];
        let currentFrame = '3M';
        const HISTORY_CACHE_PREFIX = 'delayed_history_v1';
        const QUOTE_CACHE_PREFIX = 'delayed_quote_v1';
        const FAST_RENDER_DEADLINE_MS = 1200;
        const FETCH_TIMEOUT_MS = 2200;

        const DEMO_BASE_PRICE = {
            KOSPI: 2580.12,
            KOSDAQ: 865.34,
            NASDAQ: 16520.22,
            SP500: 5150.44,
            DOW: 38800.10,
            AAPL: 187.22,
            MNQ: 20950.00,
            NQ: 20950.00,
            BTCUSD: 96000.00
        };

        const DELAYED_QUOTE_SYMBOLS = {
            KOSPI: '^KS11',
            KOSDAQ: '^KQ11',
            NASDAQ: '^IXIC',
            SP500: '^GSPC',
            DOW: '^DJI',
            AAPL: 'AAPL',
            MNQ: 'MNQ=F',
            NQ: 'NQ=F',
            BTCUSD: 'BTC-USD'
        };

        let delayedQuotes = {};
        let delayedHistoryBySymbol = {};
        let disqusLoadedForIdentifier = '';
        let liveChatClient = null;
        let liveChatChannel = null;
        let indicatorSettings = {
            maFast: 5,
            maMid: 20,
            maSlow: 60,
            emaFast: 12,
            emaSlow: 26,
            wmaPeriod: 20,
            bbPeriod: 20,
            rsiPeriod: 14,
            macdFast: 12,
            macdSlow: 26,
            macdSignal: 9,
            stochPeriod: 14,
            stochSmooth: 3,
            atrPeriod: 14,
            rocPeriod: 14,
            cciPeriod: 20,
            volumeMaPeriod: 20
        };

        const INDICATOR_DEFINITIONS = [
            { key: 'maFast', label: 'MA Fast', type: 'overlay', defaultOn: false, color: '#f59e0b' },
            { key: 'maMid', label: 'MA Mid', type: 'overlay', defaultOn: false, color: '#8b5cf6' },
            { key: 'maSlow', label: 'MA Slow', type: 'overlay', defaultOn: false, color: '#06b6d4' },
            { key: 'emaFast', label: 'EMA Fast', type: 'overlay', defaultOn: false, color: '#10b981' },
            { key: 'emaSlow', label: 'EMA Slow', type: 'overlay', defaultOn: false, color: '#ef4444' },
            { key: 'wma', label: 'WMA', type: 'overlay', defaultOn: false, color: '#0ea5e9' },
            { key: 'vwap', label: 'VWAP', type: 'overlay', defaultOn: false, color: '#0ea5e9' },
            { key: 'bbands', label: 'Bollinger', type: 'overlay-multi', defaultOn: false, color: '#6366f1' },
            { key: 'rsi', label: 'RSI', type: 'value', defaultOn: true, color: '#334155' },
            { key: 'macd', label: 'MACD', type: 'value', defaultOn: true, color: '#334155' },
            { key: 'stoch', label: 'Stochastic', type: 'value', defaultOn: true, color: '#334155' },
            { key: 'atr', label: 'ATR', type: 'value', defaultOn: false, color: '#334155' },
            { key: 'roc', label: 'ROC', type: 'value', defaultOn: false, color: '#334155' },
            { key: 'cci', label: 'CCI', type: 'value', defaultOn: false, color: '#334155' },
            { key: 'volume', label: 'Volume', type: 'value', defaultOn: true, color: '#334155' }
        ];

        let indicatorEnabled = INDICATOR_DEFINITIONS.reduce((acc, item) => {
            acc[item.key] = !!item.defaultOn;
            return acc;
        }, {});

        function format(value) {
            return Number(value || 0).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function getCurrentFrameConfig() {
            return FRAME_OPTIONS.find(opt => opt.key === currentFrame) || FRAME_OPTIONS[3];
        }

        function getHistoryCacheKey(symbol) {
            return `${HISTORY_CACHE_PREFIX}_${normalizeSymbol(symbol)}_${currentFrame}`;
        }

        function getQuoteCacheKey(symbol) {
            return `${QUOTE_CACHE_PREFIX}_${normalizeSymbol(symbol)}`;
        }

        function loadHistoryFromCache(symbol) {
            try {
                const raw = localStorage.getItem(getHistoryCacheKey(symbol));
                if (!raw) return [];
                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) return [];
                return parsed;
            } catch {
                return [];
            }
        }

        function saveHistoryToCache(symbol, history) {
            try {
                localStorage.setItem(getHistoryCacheKey(symbol), JSON.stringify(history));
            } catch {
                // ignore quota/cache errors
            }
        }

        function loadQuoteFromCache(symbol) {
            try {
                const raw = localStorage.getItem(getQuoteCacheKey(symbol));
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed.price !== 'number') return null;
                return {
                    price: Number(parsed.price),
                    prevClose: typeof parsed.prevClose === 'number' ? Number(parsed.prevClose) : null,
                    time: parsed.time ? new Date(parsed.time) : new Date()
                };
            } catch {
                return null;
            }
        }

        function saveQuoteToCache(symbol, quote) {
            try {
                localStorage.setItem(getQuoteCacheKey(symbol), JSON.stringify({
                    price: quote.price,
                    prevClose: quote.prevClose,
                    time: quote.time instanceof Date ? quote.time.toISOString() : new Date().toISOString()
                }));
            } catch {
                // ignore quota/cache errors
            }
        }

        function warmStartSymbolData(symbol) {
            if (!delayedQuotes[symbol]) {
                const cachedQuote = loadQuoteFromCache(symbol);
                if (cachedQuote) {
                    delayedQuotes[symbol] = cachedQuote;
                }
            }

            if (!delayedHistoryBySymbol[symbol] || delayedHistoryBySymbol[symbol].length === 0) {
                const cachedHistory = loadHistoryFromCache(symbol);
                if (cachedHistory.length > 0) {
                    delayedHistoryBySymbol[symbol] = cachedHistory;
                } else {
                    const quoteHistory = buildQuoteBasedHistory(symbol);
                    if (quoteHistory.length > 0) {
                        delayedHistoryBySymbol[symbol] = quoteHistory;
                    }
                }
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function fetchJsonWithFallback(url) {
            const targets = [
                url,
                `https://corsproxy.io/?${encodeURIComponent(url)}`,
                `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
            ];

            const jobs = targets.map(target => (async () => {
                const controller = new AbortController();
                const timer = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
                try {
                    const res = await fetch(target, { cache: 'no-store', signal: controller.signal });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.json();
                } finally {
                    clearTimeout(timer);
                }
            })());

            try {
                return await Promise.any(jobs);
            } catch (err) {
                throw err || new Error('Delayed data fetch failed');
            }
        }

        function renderFrameButtons() {
            const root = document.getElementById('frameToolbar');
            if (!root) return;
            root.innerHTML = '';

            FRAME_OPTIONS.forEach(opt => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = `frame-btn ${opt.key === currentFrame ? 'active' : ''}`;
                btn.textContent = opt.label;
                btn.addEventListener('click', async () => {
                    if (currentFrame === opt.key) return;
                    currentFrame = opt.key;
                    renderFrameButtons();
                    const statusEl = document.getElementById('chartStatusMessage');
                    if (statusEl) statusEl.textContent = 'Loading selected timeframe data...';
                    await refreshHistoryForSymbols([currentSymbol]);
                    applyMainSeriesData(currentSymbol);
                });
                root.appendChild(btn);
            });
        }

        function normalizeSymbol(rawSymbol) {
            const normalized = String(rawSymbol || '').trim().toUpperCase();
            if (normalized === '^KS11' || normalized === 'KS11') return 'KOSPI';
            if (normalized === '^KQ11' || normalized === 'KQ11') return 'KOSDAQ';
            if (normalized === '^GSPC' || normalized === '.GSPC') return 'SP500';
            if (normalized === '^DJI') return 'DOW';
            if (normalized === 'MNQ=F') return 'MNQ';
            if (normalized === 'NQ=F') return 'NQ';
            return normalized || 'AAPL';
        }

        function resolveYahooSymbols(symbol) {
            const normalized = normalizeSymbol(symbol);
            if (DELAYED_QUOTE_SYMBOLS[normalized]) return [DELAYED_QUOTE_SYMBOLS[normalized]];

            if (/^[0-9]{6}$/.test(normalized)) {
                return [`${normalized}.KS`, `${normalized}.KQ`, normalized];
            }

            if (normalized.includes(':')) {
                const parts = normalized.split(':');
                if (parts[1]) return [parts[1]];
            }

            return [normalized];
        }

        function symbolSeed(symbol) {
            let hash = 0;
            for (let i = 0; i < symbol.length; i++) {
                hash = ((hash << 5) - hash) + symbol.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash);
        }

        function getDayIndex(date) {
            return Math.floor(date.getTime() / 86400000);
        }

        function seededUnit(seed, step) {
            const x = Math.sin((seed * 0.0001) + (step * 12.9898)) * 43758.5453;
            return x - Math.floor(x);
        }

        function generateLightweightData(symbol) {
            const live = delayedHistoryBySymbol[symbol] || [];
            if (live.length > 0) return live;
            return loadHistoryFromCache(symbol);
        }

        function toLineData(values) {
            return lwMainData.map((point, idx) => (values[idx] == null ? null : { time: point.time, value: Number(values[idx].toFixed(2)) })).filter(Boolean);
        }

        function sanitizeIndicatorSettings(raw) {
            const norm = (value, fallback) => {
                const num = Number(value);
                if (!Number.isFinite(num)) return fallback;
                return Math.max(2, Math.min(300, Math.round(num)));
            };
            const normSmooth = (value, fallback) => {
                const num = Number(value);
                if (!Number.isFinite(num)) return fallback;
                return Math.max(1, Math.min(100, Math.round(num)));
            };
            return {
                maFast: norm(raw?.maFast, 5),
                maMid: norm(raw?.maMid, 20),
                maSlow: norm(raw?.maSlow, 60),
                emaFast: norm(raw?.emaFast, 12),
                emaSlow: norm(raw?.emaSlow, 26),
                wmaPeriod: norm(raw?.wmaPeriod, 20),
                bbPeriod: norm(raw?.bbPeriod, 20),
                rsiPeriod: norm(raw?.rsiPeriod, 14),
                macdFast: norm(raw?.macdFast, 12),
                macdSlow: norm(raw?.macdSlow, 26),
                macdSignal: norm(raw?.macdSignal, 9),
                stochPeriod: norm(raw?.stochPeriod, 14),
                stochSmooth: normSmooth(raw?.stochSmooth, 3),
                atrPeriod: norm(raw?.atrPeriod, 14),
                rocPeriod: norm(raw?.rocPeriod, 14),
                cciPeriod: norm(raw?.cciPeriod, 20),
                volumeMaPeriod: norm(raw?.volumeMaPeriod, 20)
            };
        }

        function loadIndicatorSettings() {
            try {
                const raw = localStorage.getItem(INDICATOR_SETTINGS_KEY);
                if (!raw) {
                    indicatorSettings = sanitizeIndicatorSettings(indicatorSettings);
                    return;
                }
                indicatorSettings = sanitizeIndicatorSettings(JSON.parse(raw));
            } catch {
                indicatorSettings = sanitizeIndicatorSettings(indicatorSettings);
            }
        }

        function saveIndicatorSettings() {
            try {
                localStorage.setItem(INDICATOR_SETTINGS_KEY, JSON.stringify(indicatorSettings));
            } catch {
            }
        }

        function calcSma(period, source) {
            const out = Array(source.length).fill(null);
            let sum = 0;
            for (let i = 0; i < source.length; i++) {
                sum += source[i];
                if (i >= period) sum -= source[i - period];
                if (i >= period - 1) out[i] = sum / period;
            }
            return out;
        }

        function calcEma(period, source) {
            if (!source.length) return [];
            const out = Array(source.length).fill(null);
            const alpha = 2 / (period + 1);
            let ema = source[0];
            out[0] = ema;
            for (let i = 1; i < source.length; i++) {
                ema = (source[i] * alpha) + (ema * (1 - alpha));
                out[i] = ema;
            }
            return out;
        }

        function calcWma(period, source) {
            const out = Array(source.length).fill(null);
            const denom = (period * (period + 1)) / 2;
            for (let i = period - 1; i < source.length; i++) {
                let weighted = 0;
                for (let j = 0; j < period; j++) {
                    weighted += source[i - j] * (period - j);
                }
                out[i] = weighted / denom;
            }
            return out;
        }

        function compressVolumeSeries(rawVolumes) {
            if (!Array.isArray(rawVolumes) || rawVolumes.length === 0) return [];
            const valid = rawVolumes.filter(v => Number.isFinite(v) && v >= 0).sort((a, b) => a - b);
            if (valid.length === 0) return rawVolumes.map(() => 0);
            const idx = Math.floor((valid.length - 1) * 0.90);
            const p95 = valid[Math.max(0, Math.min(valid.length - 1, idx))] || 0;
            const cap = Math.max(1, p95 * 1.10);
            return rawVolumes.map(v => Math.min(Math.max(0, Number(v) || 0), cap));
        }

        function calcStd(source, period) {
            const out = Array(source.length).fill(null);
            for (let i = period - 1; i < source.length; i++) {
                const window = source.slice(i - period + 1, i + 1);
                const mean = window.reduce((a, b) => a + b, 0) / period;
                const variance = window.reduce((a, b) => a + ((b - mean) ** 2), 0) / period;
                out[i] = Math.sqrt(variance);
            }
            return out;
        }

        function calcVwap(source) {
            const out = Array(source.length).fill(null);
            let pv = 0;
            let vv = 0;
            source.forEach((row, idx) => {
                pv += row.value * row.volume;
                vv += row.volume;
                out[idx] = vv === 0 ? row.value : pv / vv;
            });
            return out;
        }

        function calcRsiSeries(period, source) {
            const out = Array(source.length).fill(null);
            if (source.length <= period) return out;

            let gain = 0;
            let loss = 0;
            for (let i = 1; i <= period; i++) {
                const diff = source[i] - source[i - 1];
                if (diff >= 0) gain += diff;
                else loss -= diff;
            }

            let avgGain = gain / period;
            let avgLoss = loss / period;
            out[period] = avgLoss === 0 ? 100 : (100 - (100 / (1 + (avgGain / avgLoss))));

            for (let i = period + 1; i < source.length; i++) {
                const diff = source[i] - source[i - 1];
                const g = diff > 0 ? diff : 0;
                const l = diff < 0 ? -diff : 0;
                avgGain = ((avgGain * (period - 1)) + g) / period;
                avgLoss = ((avgLoss * (period - 1)) + l) / period;
                out[i] = avgLoss === 0 ? 100 : (100 - (100 / (1 + (avgGain / avgLoss))));
            }

            return out;
        }

        function calcMacdSeries(source, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const fast = Math.max(2, Math.min(300, Number(fastPeriod) || 12));
            const slow = Math.max(2, Math.min(300, Number(slowPeriod) || 26));
            const signalLen = Math.max(2, Math.min(300, Number(signalPeriod) || 9));
            const emaFast = calcEma(fast, source);
            const emaSlow = calcEma(slow, source);
            const macd = source.map((_, idx) => (emaFast[idx] == null || emaSlow[idx] == null) ? null : (emaFast[idx] - emaSlow[idx]));
            const valid = macd.map(v => v == null ? 0 : v);
            const signal = calcEma(signalLen, valid);
            const hist = macd.map((v, idx) => (v == null || signal[idx] == null) ? null : (v - signal[idx]));
            return {
                macd,
                signal,
                hist
            };
        }

        function calcStochasticSeries(period, smooth, data) {
            const k = Array(data.length).fill(null);
            for (let i = period - 1; i < data.length; i++) {
                const window = data.slice(i - period + 1, i + 1);
                const high = Math.max(...window.map(x => x.high));
                const low = Math.min(...window.map(x => x.low));
                k[i] = high === low ? 50 : (((data[i].value - low) / (high - low)) * 100);
            }

            const kSafe = k.map(v => v == null ? 50 : v);
            const d = calcSma(smooth, kSafe);
            return { k, d };
        }

        function calcAtrSeries(period, data) {
            const tr = Array(data.length).fill(null);
            for (let i = 0; i < data.length; i++) {
                const current = data[i];
                const prevClose = i === 0 ? current.value : data[i - 1].value;
                const highLow = current.high - current.low;
                const highPrev = Math.abs(current.high - prevClose);
                const lowPrev = Math.abs(current.low - prevClose);
                tr[i] = Math.max(highLow, highPrev, lowPrev);
            }
            return calcSma(period, tr.map(v => v == null ? 0 : v));
        }

        function calcRocSeries(period, source) {
            const out = Array(source.length).fill(null);
            for (let i = period; i < source.length; i++) {
                const base = source[i - period];
                if (!base) continue;
                out[i] = ((source[i] - base) / base) * 100;
            }
            return out;
        }

        function calcCciSeries(period, data) {
            const tp = data.map(d => (d.high + d.low + d.value) / 3);
            const smaTp = calcSma(period, tp);
            const out = Array(data.length).fill(null);
            for (let i = period - 1; i < data.length; i++) {
                const window = tp.slice(i - period + 1, i + 1);
                const mean = smaTp[i];
                if (mean == null) continue;
                const md = window.reduce((acc, x) => acc + Math.abs(x - mean), 0) / period;
                if (md === 0) continue;
                out[i] = (tp[i] - mean) / (0.015 * md);
            }
            return out;
        }

        function addHistogramSeriesCompat(chart, options) {
            if (typeof chart.addHistogramSeries === 'function') return chart.addHistogramSeries(options);
            if (typeof chart.addSeries === 'function' && window.LightweightCharts.HistogramSeries) {
                return chart.addSeries(window.LightweightCharts.HistogramSeries, options);
            }
            return null;
        }

        function addLineSeriesForChart(chart, options) {
            if (typeof chart.addLineSeries === 'function') return chart.addLineSeries(options);
            if (typeof chart.addSeries === 'function' && window.LightweightCharts.LineSeries) {
                return chart.addSeries(window.LightweightCharts.LineSeries, options);
            }
            return null;
        }

        function initIndicatorSubcharts() {
            if (!window.LightweightCharts) return;

            const baseOptions = {
                layout: { background: { color: '#ffffff' }, textColor: '#64748b' },
                grid: { vertLines: { color: '#f1f5f9' }, horzLines: { color: '#f1f5f9' } },
                width: document.getElementById('lightweightChart').clientWidth,
                height: 130,
                rightPriceScale: { borderColor: '#e2e8f0' },
                timeScale: { borderColor: '#e2e8f0' }
            };

            const rsiRoot = document.getElementById('rsiChart');
            const macdRoot = document.getElementById('macdChart');
            const stochRoot = document.getElementById('stochChart');
            if (!rsiRoot || !macdRoot || !stochRoot) return;

            rsiChart = LightweightCharts.createChart(rsiRoot, baseOptions);
            macdChart = LightweightCharts.createChart(macdRoot, baseOptions);
            stochChart = LightweightCharts.createChart(stochRoot, baseOptions);

            rsiSeries = addLineSeriesForChart(rsiChart, { color: '#7c3aed', lineWidth: 2 });
            rsiMidSeries = addLineSeriesForChart(rsiChart, { color: '#94a3b8', lineWidth: 1, lineStyle: 2 });

            macdLineSeries = addLineSeriesForChart(macdChart, { color: '#2563eb', lineWidth: 2 });
            macdSignalSeries = addLineSeriesForChart(macdChart, { color: '#f97316', lineWidth: 2 });
            macdHistSeries = addHistogramSeriesCompat(macdChart, { color: '#94a3b8' });

            stochKSeries = addLineSeriesForChart(stochChart, { color: '#16a34a', lineWidth: 2 });
            stochDSeries = addLineSeriesForChart(stochChart, { color: '#dc2626', lineWidth: 2 });
            stochMidSeries = addLineSeriesForChart(stochChart, { color: '#94a3b8', lineWidth: 1, lineStyle: 2 });
        }

        function renderIndicatorSubcharts(rsiSeriesData, macdSeriesData, stochSeriesData) {
            if (!rsiChart || !macdChart || !stochChart) return;

            const midline = lwMainData.map(p => ({ time: p.time, value: 50 }));
            const zeroLine = lwMainData.map(p => ({ time: p.time, value: 0 }));

            if (rsiSeries) rsiSeries.setData(indicatorEnabled.rsi ? toLineData(rsiSeriesData) : []);
            if (rsiMidSeries) rsiMidSeries.setData(indicatorEnabled.rsi ? midline : []);

            if (macdLineSeries) macdLineSeries.setData(indicatorEnabled.macd ? toLineData(macdSeriesData.macd) : []);
            if (macdSignalSeries) macdSignalSeries.setData(indicatorEnabled.macd ? toLineData(macdSeriesData.signal) : []);
            if (macdHistSeries) {
                macdHistSeries.setData(indicatorEnabled.macd
                    ? lwMainData.map((p, idx) => ({
                        time: p.time,
                        value: macdSeriesData.hist[idx] == null ? 0 : Number(macdSeriesData.hist[idx].toFixed(4)),
                        color: (macdSeriesData.hist[idx] || 0) >= 0 ? '#16a34a' : '#dc2626'
                    }))
                    : []);
            }

            if (stochKSeries) stochKSeries.setData(indicatorEnabled.stoch ? toLineData(stochSeriesData.k) : []);
            if (stochDSeries) stochDSeries.setData(indicatorEnabled.stoch ? toLineData(stochSeriesData.d) : []);
            if (stochMidSeries) stochMidSeries.setData(indicatorEnabled.stoch ? midline : []);

            rsiChart.timeScale().fitContent();
            macdChart.timeScale().fitContent();
            stochChart.timeScale().fitContent();
        }

        function addLineSeriesCompat(options) {
            if (typeof lwChart.addLineSeries === 'function') return lwChart.addLineSeries(options);
            if (typeof lwChart.addSeries === 'function' && window.LightweightCharts.LineSeries) {
                return lwChart.addSeries(window.LightweightCharts.LineSeries, options);
            }
            return null;
        }

        function createPrimarySeries(symbol) {
            const useCandle = true;
            if (useCandle) {
                if (typeof lwChart.addCandlestickSeries === 'function') {
                    lwSeriesType = 'candlestick';
                    return lwChart.addCandlestickSeries({
                        upColor: '#16a34a',
                        downColor: '#dc2626',
                        borderVisible: false,
                        wickUpColor: '#16a34a',
                        wickDownColor: '#dc2626'
                    });
                }
                if (typeof lwChart.addSeries === 'function' && window.LightweightCharts.CandlestickSeries) {
                    lwSeriesType = 'candlestick';
                    return lwChart.addSeries(window.LightweightCharts.CandlestickSeries, {
                        upColor: '#16a34a',
                        downColor: '#dc2626',
                        borderVisible: false,
                        wickUpColor: '#16a34a',
                        wickDownColor: '#dc2626'
                    });
                }
            }

            const areaOptions = {
                lineColor: '#2563eb',
                topColor: 'rgba(37, 99, 235, 0.35)',
                bottomColor: 'rgba(37, 99, 235, 0.06)',
                lineWidth: 2
            };

            if (typeof lwChart.addAreaSeries === 'function') {
                lwSeriesType = 'area';
                return lwChart.addAreaSeries(areaOptions);
            }
            if (typeof lwChart.addSeries === 'function' && window.LightweightCharts.AreaSeries) {
                lwSeriesType = 'area';
                return lwChart.addSeries(window.LightweightCharts.AreaSeries, areaOptions);
            }

            return null;
        }

        function ensureIndicatorSeries() {
            if (!lwChart || !lwSeries) return;
            if (indicatorSeriesMap.maFast) return;

            indicatorSeriesMap.maFast = addLineSeriesCompat({ color: '#f59e0b', lineWidth: 1 });
            indicatorSeriesMap.maMid = addLineSeriesCompat({ color: '#8b5cf6', lineWidth: 1 });
            indicatorSeriesMap.maSlow = addLineSeriesCompat({ color: '#06b6d4', lineWidth: 1 });
            indicatorSeriesMap.emaFast = addLineSeriesCompat({ color: '#10b981', lineWidth: 1 });
            indicatorSeriesMap.emaSlow = addLineSeriesCompat({ color: '#ef4444', lineWidth: 1 });
            indicatorSeriesMap.wma = addLineSeriesCompat({ color: '#0284c7', lineWidth: 1 });
            indicatorSeriesMap.vwap = addLineSeriesCompat({ color: '#0ea5e9', lineWidth: 1 });
            indicatorSeriesMap.bbUpper = addLineSeriesCompat({ color: '#6366f1', lineWidth: 1, lineStyle: 2 });
            indicatorSeriesMap.bbMid = addLineSeriesCompat({ color: '#6366f1', lineWidth: 1 });
            indicatorSeriesMap.bbLower = addLineSeriesCompat({ color: '#6366f1', lineWidth: 1, lineStyle: 2 });
        }

        let lastIndicatorValues = {};

        function renderIndicatorBoard(values) {
            const board = document.getElementById('indicatorValueBoard');
            if (!board) return;
            lastIndicatorValues = values || {};

            const rows = [];
            const push = (name, value) => {
                rows.push(`<div class="indicator-value-card"><div class="name">${name}</div><div class="val">${value}</div></div>`);
            };

            if (indicatorEnabled.maFast) push(`MA${indicatorSettings.maFast}`, `$${format(values.maFast)}`);
            if (indicatorEnabled.maMid) push(`MA${indicatorSettings.maMid}`, `$${format(values.maMid)}`);
            if (indicatorEnabled.maSlow) push(`MA${indicatorSettings.maSlow}`, `$${format(values.maSlow)}`);
            if (indicatorEnabled.emaFast) push(`EMA${indicatorSettings.emaFast}`, `$${format(values.emaFast)}`);
            if (indicatorEnabled.emaSlow) push(`EMA${indicatorSettings.emaSlow}`, `$${format(values.emaSlow)}`);
            if (indicatorEnabled.wma) push(`WMA${indicatorSettings.wmaPeriod}`, `$${format(values.wma)}`);
            if (indicatorEnabled.vwap) push('VWAP', `$${format(values.vwap)}`);
            if (indicatorEnabled.bbands) push('Bollinger', `$${format(values.bbLower)} / $${format(values.bbMid)} / $${format(values.bbUpper)}`);
            if (indicatorEnabled.rsi) push(`RSI(${indicatorSettings.rsiPeriod})`, `${format(values.rsi)}`);
            if (indicatorEnabled.macd) push(`MACD(${indicatorSettings.macdFast},${indicatorSettings.macdSlow},${indicatorSettings.macdSignal})`, `${format(values.macd)} / ${format(values.macdSignal)} / ${format(values.macdHist)}`);
            if (indicatorEnabled.stoch) push(`Stoch(${indicatorSettings.stochPeriod},${indicatorSettings.stochSmooth})`, `${format(values.stoch)}`);
            if (indicatorEnabled.atr) push(`ATR(${indicatorSettings.atrPeriod})`, `${format(values.atr)}`);
            if (indicatorEnabled.roc) push(`ROC(${indicatorSettings.rocPeriod})`, `${format(values.roc)}%`);
            if (indicatorEnabled.cci) push(`CCI(${indicatorSettings.cciPeriod})`, `${format(values.cci)}`);
            if (indicatorEnabled.volume) push('Volume', `${Math.round(values.volume || 0).toLocaleString()}`);
            if (indicatorEnabled.volume) push(`Vol MA(${indicatorSettings.volumeMaPeriod})`, `${Math.round(values.volumeMa || 0).toLocaleString()}`);

            board.innerHTML = rows.join('');
        }

        function renderIndicators() {
            ensureIndicatorSeries();
            if (!lwMainData.length) return;

            const closes = lwMainData.map(x => x.value);
            const maFast = calcSma(indicatorSettings.maFast, closes);
            const maMid = calcSma(indicatorSettings.maMid, closes);
            const maSlow = calcSma(indicatorSettings.maSlow, closes);
            const emaFast = calcEma(indicatorSettings.emaFast, closes);
            const emaSlow = calcEma(indicatorSettings.emaSlow, closes);
            const wma = calcWma(indicatorSettings.wmaPeriod, closes);
            const vwap = calcVwap(lwMainData);
            const std = calcStd(closes, indicatorSettings.bbPeriod);
            const bbMid = maMid;
            const bbUpper = bbMid.map((v, idx) => (v == null || std[idx] == null) ? null : (v + (2 * std[idx])));
            const bbLower = bbMid.map((v, idx) => (v == null || std[idx] == null) ? null : (v - (2 * std[idx])));
            const volumes = lwMainData.map(x => Number(x.volume || 0));
            const volumeCompressed = compressVolumeSeries(volumes);
            const volumeMa = calcSma(indicatorSettings.volumeMaPeriod, volumes);
            const volumeMaCompressed = calcSma(indicatorSettings.volumeMaPeriod, volumeCompressed);

            const bindSeries = (key, values) => {
                const series = indicatorSeriesMap[key];
                if (!series) return;
                series.setData(indicatorEnabled[key] ? toLineData(values) : []);
            };

            bindSeries('maFast', maFast);
            bindSeries('maMid', maMid);
            bindSeries('maSlow', maSlow);
            bindSeries('emaFast', emaFast);
            bindSeries('emaSlow', emaSlow);
            bindSeries('wma', wma);
            bindSeries('vwap', vwap);
            indicatorSeriesMap.bbUpper?.setData(indicatorEnabled.bbands ? toLineData(bbUpper) : []);
            indicatorSeriesMap.bbMid?.setData(indicatorEnabled.bbands ? toLineData(bbMid) : []);
            indicatorSeriesMap.bbLower?.setData(indicatorEnabled.bbands ? toLineData(bbLower) : []);
            if (volumeHistSeries) {
                volumeHistSeries.setData(indicatorEnabled.volume
                    ? lwMainData.map((point, idx) => {
                        const prev = idx === 0 ? point.value : lwMainData[idx - 1].value;
                        return {
                            time: point.time,
                            value: Number(volumeCompressed[idx] || 0),
                            color: point.value >= prev ? 'rgba(22,163,74,0.65)' : 'rgba(220,38,38,0.65)'
                        };
                    })
                    : []);
            }
            if (volumeMaSeries) {
                volumeMaSeries.setData(indicatorEnabled.volume
                    ? lwMainData.map((point, idx) => {
                        const value = volumeMaCompressed[idx];
                        if (value == null) return null;
                        return { time: point.time, value: Number(value) };
                    }).filter(Boolean)
                    : []);
            }

            const rsiSeriesData = calcRsiSeries(indicatorSettings.rsiPeriod, closes);
            const macdSeriesData = calcMacdSeries(closes, indicatorSettings.macdFast, indicatorSettings.macdSlow, indicatorSettings.macdSignal);
            const stochSeriesData = calcStochasticSeries(indicatorSettings.stochPeriod, indicatorSettings.stochSmooth, lwMainData);
            const atrSeriesData = calcAtrSeries(indicatorSettings.atrPeriod, lwMainData);
            const rocSeriesData = calcRocSeries(indicatorSettings.rocPeriod, closes);
            const cciSeriesData = calcCciSeries(indicatorSettings.cciPeriod, lwMainData);
            renderIndicatorSubcharts(rsiSeriesData, macdSeriesData, stochSeriesData);
            const last = closes.length - 1;
            renderIndicatorBoard({
                maFast: maFast[maFast.length - 1],
                maMid: maMid[maMid.length - 1],
                maSlow: maSlow[maSlow.length - 1],
                emaFast: emaFast[emaFast.length - 1],
                emaSlow: emaSlow[emaSlow.length - 1],
                wma: wma[wma.length - 1],
                vwap: vwap[vwap.length - 1],
                bbUpper: bbUpper[bbUpper.length - 1],
                bbMid: bbMid[bbMid.length - 1],
                bbLower: bbLower[bbLower.length - 1],
                rsi: rsiSeriesData[last],
                macd: macdSeriesData.macd[last],
                macdSignal: macdSeriesData.signal[last],
                macdHist: macdSeriesData.hist[last],
                stoch: stochSeriesData.k[last],
                atr: atrSeriesData[last],
                roc: rocSeriesData[last],
                cci: cciSeriesData[last],
                volume: volumes[last],
                volumeMa: volumeMa[last]
            });
        }

        function applyMainSeriesData(symbol) {
            const nextData = generateLightweightData(symbol);
            const statusEl = document.getElementById('chartStatusMessage');

            if (!nextData.length) {
                if (statusEl) statusEl.textContent = 'Failed to receive chart data: no delayed quote response. This may be due to network/CORS limits or provider latency.';
                renderIndicators();
                return;
            }

            lwMainData = nextData;
            if (statusEl) statusEl.textContent = '';
            if (lwSeries) {
                if (lwSeriesType === 'candlestick') {
                    lwSeries.setData(lwMainData.map((x, idx) => {
                        const open = idx === 0 ? x.value : lwMainData[idx - 1].value;
                        return {
                            time: x.time,
                            open: Number(open.toFixed(2)),
                            high: x.high,
                            low: x.low,
                            close: x.value
                        };
                    }));
                } else {
                    lwSeries.setData(lwMainData.map(x => ({ time: x.time, value: x.value })));
                }
            }
            renderIndicators();
        }

        function getDemoPrice(symbol) {
            return null;
        }

        async function fetchDelayedQuote(symbol) {
            const candidates = resolveYahooSymbols(symbol);
            if (!candidates.length) return;

            const quoteRequest = (async () => {
                const url = `https://query1.finance.yahoo.com/v7/finance/quote?symbols=${encodeURIComponent(candidates.join(','))}`;
                const data = await fetchJsonWithFallback(url);
                const results = data?.quoteResponse?.result || [];
                const item = results.find(r => typeof r?.regularMarketPrice === 'number');
                if (!item || typeof item.regularMarketPrice !== 'number') throw new Error('Delayed quote payload error');
                return {
                    price: Number(item.regularMarketPrice),
                    prevClose: typeof item.regularMarketPreviousClose === 'number' ? Number(item.regularMarketPreviousClose) : null,
                    time: typeof item.regularMarketTime === 'number' ? new Date(item.regularMarketTime * 1000) : new Date()
                };
            })();

            const chartMetaRequests = candidates.map(yahooSymbol => (async () => {
                const url = `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(yahooSymbol)}?range=5d&interval=1d`;
                const data = await fetchJsonWithFallback(url);
                const result = data?.chart?.result?.[0];
                const meta = result?.meta || {};
                const closes = result?.indicators?.quote?.[0]?.close || [];
                const validCloses = closes.filter(v => typeof v === 'number');
                const marketPrice = typeof meta.regularMarketPrice === 'number'
                    ? Number(meta.regularMarketPrice)
                    : Number(validCloses[validCloses.length - 1]);
                if (!Number.isFinite(marketPrice)) throw new Error('No market price in chart meta');
                const prevClose = typeof meta.chartPreviousClose === 'number'
                    ? Number(meta.chartPreviousClose)
                    : (validCloses.length > 1 ? Number(validCloses[validCloses.length - 2]) : marketPrice);
                return {
                    price: marketPrice,
                    prevClose: Number.isFinite(prevClose) ? prevClose : null,
                    time: new Date()
                };
            })());

            const quote = await Promise.any([quoteRequest, ...chartMetaRequests]);
            delayedQuotes[symbol] = quote;
            saveQuoteToCache(symbol, delayedQuotes[symbol]);
        }

        async function fetchDelayedHistory(symbol) {
            const symbolCandidates = resolveYahooSymbols(symbol);
            if (!symbolCandidates.length) return;

            const frame = getCurrentFrameConfig();
            const candidates = [
                { range: frame.range, interval: frame.interval },
                { range: '1mo', interval: '1h' },
                { range: '3mo', interval: '1d' },
                { range: '6mo', interval: '1d' }
            ];

            const parseHistory = (data) => {
                const result = data?.chart?.result?.[0];
                const timestamps = result?.timestamp || [];
                const quote = result?.indicators?.quote?.[0] || {};
                const opens = quote.open || [];
                const highs = quote.high || [];
                const lows = quote.low || [];
                const closes = quote.close || [];
                const volumes = quote.volume || [];

                const history = [];
                for (let i = 0; i < timestamps.length; i++) {
                    const close = closes[i];
                    if (close == null) continue;
                    const open = opens[i] == null ? close : opens[i];
                    const high = highs[i] == null ? Math.max(open, close) : highs[i];
                    const low = lows[i] == null ? Math.min(open, close) : lows[i];
                    history.push({
                        time: Number(timestamps[i]),
                        value: Number(close),
                        high: Number(high),
                        low: Number(low),
                        volume: Math.max(0, Number(volumes[i] || 0))
                    });
                }
                return history;
            };

            const requestFor = (yahooSymbol, candidate) => (async () => {
                const url = `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(yahooSymbol)}?range=${candidate.range}&interval=${candidate.interval}`;
                const data = await fetchJsonWithFallback(url);
                const history = parseHistory(data);
                if (!history.length) throw new Error('Empty history');
                return history;
            })();

            const primaryRequests = symbolCandidates.map(yahooSymbol => requestFor(yahooSymbol, candidates[0]));
            try {
                const primary = await Promise.any(primaryRequests);
                delayedHistoryBySymbol[symbol] = primary;
                saveHistoryToCache(symbol, primary);
                return;
            } catch {
                // fallback tier
            }

            const fallbackRequests = [];
            for (const yahooSymbol of symbolCandidates) {
                for (let i = 1; i < candidates.length; i++) {
                    fallbackRequests.push(requestFor(yahooSymbol, candidates[i]));
                }
            }

            if (!fallbackRequests.length) return;

            try {
                const fallbackHistory = await Promise.any(fallbackRequests);
                delayedHistoryBySymbol[symbol] = fallbackHistory;
                saveHistoryToCache(symbol, fallbackHistory);
            } catch {
                // keep previous/cached data
            }
        }

        function buildQuoteBasedHistory(symbol) {
            const quote = delayedQuotes[symbol];
            if (!quote || typeof quote.price !== 'number') return [];

            const now = quote.time instanceof Date ? quote.time : new Date();
            const todayTs = Math.floor(now.getTime() / 1000);
            const prevTs = todayTs - 86400;
            const prevClose = typeof quote.prevClose === 'number' ? quote.prevClose : quote.price;
            const high = Math.max(quote.price, prevClose);
            const low = Math.min(quote.price, prevClose);

            return [
                {
                    time: prevTs,
                    value: Number(prevClose),
                    high: Number(high),
                    low: Number(low),
                    volume: 0
                },
                {
                    time: todayTs,
                    value: Number(quote.price),
                    high: Number(high),
                    low: Number(low),
                    volume: 0
                }
            ];
        }

        async function refreshQuotesForSymbols(symbols) {
            const uniqueSymbols = Array.from(new Set(symbols.filter(Boolean)));
            if (uniqueSymbols.length === 0) return;

            await Promise.allSettled(uniqueSymbols.map(async (symbol) => {
                try {
                    await fetchDelayedQuote(symbol);
                } catch (err) {
                    // fallback keeps deterministic demo price
                }
            }));
        }

        async function refreshHistoryForSymbols(symbols) {
            const uniqueSymbols = Array.from(new Set(symbols.filter(Boolean)));
            if (uniqueSymbols.length === 0) return;

            await Promise.allSettled(uniqueSymbols.map(async (symbol) => {
                try {
                    await fetchDelayedHistory(symbol);
                } catch (err) {
                    // keep last successful/cached history to avoid blank chart flicker
                }
            }));
        }

        async function refreshRealtimeValuation() {
            if (realtimeRefreshInFlight) return;
            realtimeRefreshInFlight = true;

            const portfolioSymbols = Object.keys(simPortfolio);
            warmStartSymbolData(currentSymbol);
            try {
                const quotePromise = refreshQuotesForSymbols([currentSymbol, ...portfolioSymbols]);
                const historyPromise = refreshHistoryForSymbols([currentSymbol]);

                await Promise.race([historyPromise, sleep(FAST_RENDER_DEADLINE_MS)]);

                if (!delayedHistoryBySymbol[currentSymbol] || delayedHistoryBySymbol[currentSymbol].length === 0) {
                    await Promise.race([quotePromise, sleep(FAST_RENDER_DEADLINE_MS)]);
                    delayedHistoryBySymbol[currentSymbol] = buildQuoteBasedHistory(currentSymbol);
                }

                if (lwSeries) applyMainSeriesData(currentSymbol);

                await Promise.allSettled([quotePromise, historyPromise]);
                if (lwSeries) applyMainSeriesData(currentSymbol);

                const source = document.getElementById('lightweightSource');
                if (source && (!delayedHistoryBySymbol[currentSymbol] || delayedHistoryBySymbol[currentSymbol].length === 0)) {
                    source.textContent = 'This educational chart is delayed by approximately 15 minutes. Source: Lightweight Charts by TradingView (delayed history unavailable; only current delayed quote shown).';
                }

                renderEntryPriceLine();
                renderTradeMarkers();
                renderSimState();

                const passiveBreach = getPassiveRiskBreachDetail();
                if (passiveBreach) {
                    blowPropAccountByRule(`${passiveBreach.code}: ${passiveBreach.message}`);
                    return;
                }
            } finally {
                realtimeRefreshInFlight = false;
            }
        }

        function renderIndicatorToggles() {
            const root = document.getElementById('indicatorToggleList');
            if (!root) return;
            root.innerHTML = '';

            const getDynamicLabel = (ind) => {
                if (ind.key === 'maFast') return `MA ${indicatorSettings.maFast}`;
                if (ind.key === 'maMid') return `MA ${indicatorSettings.maMid}`;
                if (ind.key === 'maSlow') return `MA ${indicatorSettings.maSlow}`;
                if (ind.key === 'emaFast') return `EMA ${indicatorSettings.emaFast}`;
                if (ind.key === 'emaSlow') return `EMA ${indicatorSettings.emaSlow}`;
                if (ind.key === 'wma') return `WMA ${indicatorSettings.wmaPeriod}`;
                if (ind.key === 'rsi') return `RSI ${indicatorSettings.rsiPeriod}`;
                if (ind.key === 'atr') return `ATR ${indicatorSettings.atrPeriod}`;
                if (ind.key === 'roc') return `ROC ${indicatorSettings.rocPeriod}`;
                if (ind.key === 'cci') return `CCI ${indicatorSettings.cciPeriod}`;
                return ind.label;
            };

            INDICATOR_DEFINITIONS.forEach(ind => {
                const label = document.createElement('label');
                label.className = 'indicator-item';
                label.innerHTML = `<input type="checkbox" data-indicator="${ind.key}" ${indicatorEnabled[ind.key] ? 'checked' : ''} /><span>${getDynamicLabel(ind)}</span>`;
                root.appendChild(label);
            });

            root.querySelectorAll('input[data-indicator]').forEach(input => {
                input.addEventListener('change', (event) => {
                    const key = event.target.dataset.indicator;
                    indicatorEnabled[key] = !!event.target.checked;
                    renderIndicators();
                });
            });
        }

        function renderIndicatorSettings() {
            const panel = document.getElementById('indicatorSettingsPanel');
            if (!panel) return;
            const idToKey = {
                maFastPeriodInput: 'maFast',
                maMidPeriodInput: 'maMid',
                maSlowPeriodInput: 'maSlow',
                emaFastPeriodInput: 'emaFast',
                emaSlowPeriodInput: 'emaSlow',
                wmaPeriodInput: 'wmaPeriod',
                bbPeriodInput: 'bbPeriod',
                rsiPeriodInput: 'rsiPeriod',
                macdFastPeriodInput: 'macdFast',
                macdSlowPeriodInput: 'macdSlow',
                macdSignalPeriodInput: 'macdSignal',
                stochPeriodInput: 'stochPeriod',
                stochSmoothInput: 'stochSmooth',
                atrPeriodInput: 'atrPeriod',
                rocPeriodInput: 'rocPeriod',
                cciPeriodInput: 'cciPeriod',
                volumeMaPeriodInput: 'volumeMaPeriod'
            };

            Object.entries(idToKey).forEach(([id, key]) => {
                const input = document.getElementById(id);
                if (!input) return;
                input.value = String(indicatorSettings[key]);
                input.onchange = () => {
                    indicatorSettings[key] = Number(input.value || indicatorSettings[key]);
                    indicatorSettings = sanitizeIndicatorSettings(indicatorSettings);
                    saveIndicatorSettings();
                    renderIndicatorToggles();
                    const rsiTitle = document.querySelector('#rsiChart')?.previousElementSibling;
                    const macdTitle = document.querySelector('#macdChart')?.previousElementSibling;
                    const stochTitle = document.querySelector('#stochChart')?.previousElementSibling;
                    if (rsiTitle) rsiTitle.textContent = `RSI (${indicatorSettings.rsiPeriod})`;
                    if (macdTitle) macdTitle.textContent = `MACD (${indicatorSettings.macdFast}, ${indicatorSettings.macdSlow}, ${indicatorSettings.macdSignal})`;
                    if (stochTitle) stochTitle.textContent = `Stochastic (${indicatorSettings.stochPeriod}, ${indicatorSettings.stochSmooth})`;
                    renderIndicators();
                };
            });

            const rsiTitle = document.querySelector('#rsiChart')?.previousElementSibling;
            const macdTitle = document.querySelector('#macdChart')?.previousElementSibling;
            const stochTitle = document.querySelector('#stochChart')?.previousElementSibling;
            if (rsiTitle) rsiTitle.textContent = `RSI (${indicatorSettings.rsiPeriod})`;
            if (macdTitle) macdTitle.textContent = `MACD (${indicatorSettings.macdFast}, ${indicatorSettings.macdSlow}, ${indicatorSettings.macdSignal})`;
            if (stochTitle) stochTitle.textContent = `Stochastic (${indicatorSettings.stochPeriod}, ${indicatorSettings.stochSmooth})`;
        }

        function renderEntryPriceLine() {
            if (!lwSeries) return;

            if (lwEntryLine) {
                lwSeries.removePriceLine(lwEntryLine);
                lwEntryLine = null;
            }

            const holding = simPortfolio[currentSymbol];
            if (!holding || !holding.qty) return;

            lwEntryLine = lwSeries.createPriceLine({
                price: Number(holding.avgPrice.toFixed(2)),
                color: '#dc2626',
                lineWidth: 2,
                lineStyle: 2,
                axisLabelVisible: true,
                title: 'Average Entry'
            });
        }

        function renderTradeMarkers() {
            if (!lwSeries || typeof lwSeries.setMarkers !== 'function') return;
            lwSeries.setMarkers(lwTradeMarkers);
        }

        function appendTradeMarker(side, price) {
            const lastBar = lwMainData[lwMainData.length - 1];
            const markerTime = lastBar ? lastBar.time : Math.floor(Date.now() / 1000);
            lwTradeMarkers.push({
                time: markerTime,
                position: side === 'buy' ? 'belowBar' : 'aboveBar',
                color: side === 'buy' ? '#16a34a' : '#dc2626',
                shape: side === 'buy' ? 'arrowUp' : 'arrowDown',
                text: `${side.toUpperCase()} $${format(price)}`
            });
            if (lwTradeMarkers.length > 200) {
                lwTradeMarkers = lwTradeMarkers.slice(lwTradeMarkers.length - 200);
            }
            renderTradeMarkers();
        }

        function initLightweightChart() {
            const root = document.getElementById('lightweightChart');
            if (!root || !window.LightweightCharts) return;
            lwChart = LightweightCharts.createChart(root, {
                width: root.clientWidth,
                height: 340,
                layout: {
                    background: { color: '#ffffff' },
                    textColor: '#334155'
                },
                grid: {
                    vertLines: { color: '#f1f5f9' },
                    horzLines: { color: '#f1f5f9' }
                }
            });

            const volumeRoot = document.getElementById('volumeChart');
            if (volumeRoot) {
                volumeChart = LightweightCharts.createChart(volumeRoot, {
                    width: volumeRoot.clientWidth,
                    height: 78,
                    layout: {
                        background: { color: '#ffffff' },
                        textColor: '#94a3b8'
                    },
                    grid: {
                        vertLines: { color: '#f1f5f9' },
                        horzLines: { color: '#f1f5f9' }
                    },
                    rightPriceScale: { borderColor: '#e2e8f0' },
                    timeScale: { borderColor: '#e2e8f0' }
                });
                volumeHistSeries = addHistogramSeriesCompat(volumeChart, {
                    priceFormat: { type: 'volume' },
                    lastValueVisible: false,
                    priceLineVisible: false
                });
                volumeMaSeries = addLineSeriesForChart(volumeChart, {
                    color: '#475569',
                    lineWidth: 1,
                    lastValueVisible: false,
                    priceLineVisible: false
                });
            }

            lwSeries = createPrimarySeries(currentSymbol);
            if (!lwSeries) {
                document.getElementById('lightweightSource').textContent = 'Chart load failed: Lightweight Charts version compatibility issue.';
                return;
            }

            applyMainSeriesData(currentSymbol);
            renderFrameButtons();
            loadIndicatorSettings();
            renderIndicatorToggles();
            renderIndicatorSettings();
            initIndicatorSubcharts();
            renderIndicators();
            window.addEventListener('resize', () => {
                lwChart.applyOptions({ width: root.clientWidth });
                const width = root.clientWidth;
                if (volumeChart) {
                    const volumeRootEl = document.getElementById('volumeChart');
                    volumeChart.applyOptions({ width: volumeRootEl ? volumeRootEl.clientWidth : width });
                }
                if (rsiChart) rsiChart.applyOptions({ width });
                if (macdChart) macdChart.applyOptions({ width });
                if (stochChart) stochChart.applyOptions({ width });
            });
        }

        function updateChartsForSymbol(symbol) {
            document.getElementById('chartTitle').textContent = `${symbol} Chart`;
            const targetSeriesType = 'candlestick';
            if (lwSeries && lwSeriesType !== targetSeriesType && lwChart.removeSeries) {
                lwChart.removeSeries(lwSeries);
                lwSeries = createPrimarySeries(symbol);
            }
            warmStartSymbolData(symbol);
            if (lwSeries) applyMainSeriesData(symbol);
            const source = document.getElementById('lightweightSource');
            if (source) {
                source.textContent = 'This educational chart is delayed by approximately 15 minutes. Source: Lightweight Charts by TradingView (candlestick mode for all symbols, delayed quotes preferred).';
            }
            renderEntryPriceLine();
            renderTradeMarkers();
            renderSimState();
            refreshRealtimeValuation();
        }

        function getSimSessionKey() {
            return localStorage.getItem('local_auth_session_v1') || 'guest';
        }

        function isPersistentSimSession() {
            return getSimSessionKey() !== 'guest';
        }

        function getSimStorageKey(suffix) {
            return `merged_sim_v1_${getSimSessionKey()}_${suffix}`;
        }

        function getPropRulesStorageKey() {
            return `prop_rules_v1_${getSimSessionKey()}`;
        }

        function getPropRuleStateStorageKey() {
            return `prop_rule_state_v1_${getSimSessionKey()}`;
        }

        function getPropPresetStorageKey() {
            return `prop_preset_v1_${getSimSessionKey()}`;
        }

        function getResetClickCountStorageKey() {
            return `${RESET_CLICK_COUNT_KEY}_${getSimSessionKey()}`;
        }

        function getResetAdGrantStorageKey() {
            return `${RESET_AD_GRANT_KEY}_${getSimSessionKey()}`;
        }

        function bumpManualResetClickCount() {
            const key = getResetClickCountStorageKey();
            let next = 1;
            try {
                const current = Number(localStorage.getItem(key) || '0');
                next = Number.isFinite(current) ? current + 1 : 1;
                localStorage.setItem(key, String(next));
            } catch {
                next = 1;
            }
            return next;
        }

        function consumeResetAdGrant() {
            const key = getResetAdGrantStorageKey();
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return false;
                localStorage.removeItem(key);
                return true;
            } catch {
                return false;
            }
        }

        function getDefaultPropRules() {
            return { ...PROP_RULES_DEFAULT };
        }

        function sanitizePropRuleValues(raw, fallbackMode = 'custom') {
            return {
                mode: ['custom', 'eod', 'tmdd'].includes(raw?.mode) ? raw.mode : fallbackMode,
                startingBalance: [25000, 50000, 100000].includes(Number(raw?.startingBalance)) ? Number(raw.startingBalance) : 100000,
                dailyLossPct: Math.min(50, Math.max(0.1, Number(raw?.dailyLossPct) || 5)),
                maxDrawdownPct: Math.min(90, Math.max(0.1, Number(raw?.maxDrawdownPct) || 10)),
                consistencyPct: Math.min(100, Math.max(1, Number(raw?.consistencyPct) || 35)),
                maxTradesPerDay: Math.min(500, Math.max(1, Number(raw?.maxTradesPerDay) || 30)),
                maxOpenPositions: Math.min(100, Math.max(1, Number(raw?.maxOpenPositions) || 5)),
                maxQtyPerOrder: Math.min(1000000, Math.max(1, Number(raw?.maxQtyPerOrder) || 500)),
                maxPositionPct: Math.min(100, Math.max(1, Number(raw?.maxPositionPct) || 60))
            };
        }

        function loadPropPresetConfigs() {
            propPresetConfigs = {
                custom: { ...PROP_PRESETS_DEFAULT.custom },
                eod: { ...PROP_PRESETS_DEFAULT.eod },
                tmdd: { ...PROP_PRESETS_DEFAULT.tmdd }
            };

            if (!isPersistentSimSession()) return;
            try {
                const raw = localStorage.getItem(getPropPresetStorageKey());
                if (!raw) return;
                const parsed = JSON.parse(raw);
                ['custom', 'eod', 'tmdd'].forEach(mode => {
                    if (!parsed?.[mode]) return;
                    propPresetConfigs[mode] = sanitizePropRuleValues(parsed[mode], mode);
                });
            } catch {
            }
        }

        function savePropPresetConfigs() {
            if (!isPersistentSimSession()) return;
            localStorage.setItem(getPropPresetStorageKey(), JSON.stringify(propPresetConfigs));
        }

        function getSimTotalEquity() {
            let total = simCash;
            Object.keys(simPortfolio).forEach(sym => {
                const holding = simPortfolio[sym];
                const current = getCurrentDemoPrice(sym);
                total += (current == null ? holding.avgPrice : current) * holding.qty;
            });
            return total;
        }

        function loadPropRules() {
            propRules = getDefaultPropRules();
            if (!isPersistentSimSession()) {
                simBaseCash = SIM_INITIAL_CASH;
                return;
            }
            try {
                const raw = localStorage.getItem(getPropRulesStorageKey());
                if (!raw) {
                    simBaseCash = propRules.startingBalance;
                    return;
                }
                const parsed = JSON.parse(raw);
                propRules = sanitizePropRuleValues(parsed, parsed?.mode || 'custom');
            } catch {
                propRules = getDefaultPropRules();
            }
            simBaseCash = propRules.startingBalance;
        }

        function savePropRules() {
            if (!isPersistentSimSession()) return;
            localStorage.setItem(getPropRulesStorageKey(), JSON.stringify(propRules));
        }

        function loadPropRuleState() {
            const defaultEquity = getSimTotalEquity();
            propRuleDay = new Date().toISOString().slice(0, 10);
            propDailyStartEquity = defaultEquity;
            propPeakEquity = defaultEquity;
            propAccountFailedReason = '';

            if (!isPersistentSimSession()) return;
            try {
                const raw = localStorage.getItem(getPropRuleStateStorageKey());
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (typeof parsed?.day === 'string') propRuleDay = parsed.day;
                if (typeof parsed?.dailyStartEquity === 'number') propDailyStartEquity = parsed.dailyStartEquity;
                if (typeof parsed?.peakEquity === 'number') propPeakEquity = parsed.peakEquity;
                if (typeof parsed?.failedReason === 'string') propAccountFailedReason = parsed.failedReason;
            } catch {
            }
        }

        function savePropRuleState() {
            if (!isPersistentSimSession()) return;
            localStorage.setItem(getPropRuleStateStorageKey(), JSON.stringify({
                day: propRuleDay,
                dailyStartEquity: propDailyStartEquity,
                peakEquity: propPeakEquity,
                failedReason: propAccountFailedReason
            }));
        }

        function ensurePropRuleState() {
            const nowDay = new Date().toISOString().slice(0, 10);
            const equity = getSimTotalEquity();
            if (!propRuleDay || propRuleDay !== nowDay) {
                propRuleDay = nowDay;
                propDailyStartEquity = equity;
            }
            if (!propPeakEquity || equity > propPeakEquity) {
                propPeakEquity = equity;
            }
            savePropRuleState();
        }

        function getTodayTradeCount() {
            const today = new Date().toISOString().slice(0, 10);
            return simTxs.filter(tx => {
                const stamp = typeof tx?.ts === 'number' ? tx.ts : Date.parse(tx?.date || '');
                if (!Number.isFinite(stamp)) return false;
                return new Date(stamp).toISOString().slice(0, 10) === today;
            }).length;
        }

        function getRuleBreachDetail({ side, symbol, qty, price, orderNotional = 0 }) {
            ensurePropRuleState();
            if (propAccountFailedReason) {
                return { code: 'ACCOUNT_FAILED', message: propAccountFailedReason };
            }
            const equity = getSimTotalEquity();

            if (qty > propRules.maxQtyPerOrder) {
                return { code: 'MAX_QTY', message: `Max qty per order breached (${qty} > ${propRules.maxQtyPerOrder}).` };
            }

            const tradesToday = getTodayTradeCount();
            if ((tradesToday + 1) > propRules.maxTradesPerDay) {
                return { code: 'MAX_TRADES', message: `Max trades per day breached (${tradesToday + 1} > ${propRules.maxTradesPerDay}).` };
            }

            const dailyLossPct = propDailyStartEquity > 0
                ? ((propDailyStartEquity - equity) / propDailyStartEquity) * 100
                : 0;
            if (dailyLossPct > propRules.dailyLossPct) {
                return { code: 'DAILY_LOSS', message: `Daily loss rule breached (${dailyLossPct.toFixed(2)}% > ${propRules.dailyLossPct.toFixed(2)}%).` };
            }

            const drawdownBase = propRules.mode === 'tmdd' ? propPeakEquity : simBaseCash;
            const maxLossAllowed = drawdownBase * (propRules.maxDrawdownPct / 100);
            if ((drawdownBase - equity) > maxLossAllowed) {
                return { code: 'DRAWDOWN', message: `${propRules.mode.toUpperCase()} drawdown rule breached.` };
            }

            const existingPositions = Object.keys(simPortfolio).filter(sym => (simPortfolio[sym]?.qty || 0) !== 0).length;
            const currentQty = simPortfolio[symbol]?.qty || 0;

            if (side === 'buy') {
                const projectedQty = currentQty + qty;
                const nextPositions = currentQty !== 0
                    ? existingPositions - (projectedQty === 0 ? 1 : 0)
                    : (projectedQty !== 0 ? existingPositions + 1 : existingPositions);
                if (nextPositions > propRules.maxOpenPositions) {
                    return { code: 'MAX_POSITIONS', message: `Max open positions breached (${nextPositions} > ${propRules.maxOpenPositions}).` };
                }

                const positionNotional = Math.abs(projectedQty) * price;
                const positionCap = equity * (propRules.maxPositionPct / 100);
                if (positionNotional > positionCap) {
                    return { code: 'POSITION_CAP', message: `Max position notional breached (${propRules.maxPositionPct}% cap).` };
                }
            }

            if (side === 'sell') {
                const projectedQty = currentQty - qty;
                const nextPositions = currentQty !== 0
                    ? existingPositions - (projectedQty === 0 ? 1 : 0)
                    : (projectedQty !== 0 ? existingPositions + 1 : existingPositions);
                if (nextPositions > propRules.maxOpenPositions) {
                    return { code: 'MAX_POSITIONS', message: `Max open positions breached (${nextPositions} > ${propRules.maxOpenPositions}).` };
                }

                const positionNotional = Math.abs(projectedQty) * price;
                const positionCap = equity * (propRules.maxPositionPct / 100);
                if (positionNotional > positionCap) {
                    return { code: 'POSITION_CAP', message: `Max position notional breached (${propRules.maxPositionPct}% cap).` };
                }
            }

            if (orderNotional > 0) {
                const cap = equity * (propRules.consistencyPct / 100);
                if (orderNotional > cap) {
                    return { code: 'CONSISTENCY', message: `Consistency rule breached (order > ${propRules.consistencyPct}% of equity).` };
                }
            }

            return null;
        }

        function getPassiveRiskBreachDetail() {
            ensurePropRuleState();
            if (propAccountFailedReason) {
                return { code: 'ACCOUNT_FAILED', message: propAccountFailedReason };
            }

            const equity = getSimTotalEquity();
            const dailyLossPct = propDailyStartEquity > 0
                ? ((propDailyStartEquity - equity) / propDailyStartEquity) * 100
                : 0;
            if (dailyLossPct > propRules.dailyLossPct) {
                return { code: 'DAILY_LOSS', message: `Daily loss rule breached (${dailyLossPct.toFixed(2)}% > ${propRules.dailyLossPct.toFixed(2)}%).` };
            }

            const drawdownBase = propRules.mode === 'tmdd' ? propPeakEquity : simBaseCash;
            const maxLossAllowed = drawdownBase * (propRules.maxDrawdownPct / 100);
            if ((drawdownBase - equity) > maxLossAllowed) {
                return { code: 'DRAWDOWN', message: `${propRules.mode.toUpperCase()} drawdown rule breached.` };
            }

            return null;
        }

        function setActivePresetButton(mode) {
            const btnMap = {
                custom: document.getElementById('propPresetCustomBtn'),
                eod: document.getElementById('propPresetEodBtn'),
                tmdd: document.getElementById('propPresetTmddBtn')
            };
            Object.entries(btnMap).forEach(([key, btn]) => {
                if (!btn) return;
                btn.classList.toggle('active', key === mode);
            });
        }

        function syncPropRuleUI() {
            const account = document.getElementById('propAccountSize');
            const daily = document.getElementById('propDailyLossPct');
            const drawdown = document.getElementById('propMaxDrawdownPct');
            const consistency = document.getElementById('propConsistencyPct');
            const maxTradesPerDay = document.getElementById('propMaxTradesPerDay');
            const maxOpenPositions = document.getElementById('propMaxOpenPositions');
            const maxQtyPerOrder = document.getElementById('propMaxQtyPerOrder');
            const maxPositionPct = document.getElementById('propMaxPositionPct');
            const applyBtn = document.getElementById('propApplyRulesBtn');
            const resetBtn = document.getElementById('propResetAccountBtn');
            const memberNote = document.getElementById('propRuleMemberNote');
            const controls = [account, daily, drawdown, consistency, maxTradesPerDay, maxOpenPositions, maxQtyPerOrder, maxPositionPct, applyBtn, resetBtn, document.getElementById('propPresetCustomBtn'), document.getElementById('propPresetEodBtn'), document.getElementById('propPresetTmddBtn')];

            if (account) account.value = String(propRules.startingBalance);
            if (daily) daily.value = String(propRules.dailyLossPct);
            if (drawdown) drawdown.value = String(propRules.maxDrawdownPct);
            if (consistency) consistency.value = String(propRules.consistencyPct);
            if (maxTradesPerDay) maxTradesPerDay.value = String(propRules.maxTradesPerDay);
            if (maxOpenPositions) maxOpenPositions.value = String(propRules.maxOpenPositions);
            if (maxQtyPerOrder) maxQtyPerOrder.value = String(propRules.maxQtyPerOrder);
            if (maxPositionPct) maxPositionPct.value = String(propRules.maxPositionPct);
            setActivePresetButton(propRules.mode);

            const canEdit = isPersistentSimSession();
            controls.forEach(el => {
                if (el) el.disabled = !canEdit;
            });
            if (memberNote) {
                memberNote.textContent = canEdit
                    ? 'Member mode: you can edit account size and prop rules.'
                    : 'Login required: guests can trade demo but cannot change prop rules.';
            }
        }

        function renderPropRuleStatus() {
            const status = document.getElementById('propRuleStatus');
            const failBadge = document.getElementById('propRuleFailBadge');
            if (!status) return;
            ensurePropRuleState();
            const equity = getSimTotalEquity();
            const dailyLossPct = propDailyStartEquity > 0
                ? ((propDailyStartEquity - equity) / propDailyStartEquity) * 100
                : 0;
            const drawdownBase = propRules.mode === 'tmdd' ? propPeakEquity : simBaseCash;
            const drawdownPct = drawdownBase > 0 ? ((drawdownBase - equity) / drawdownBase) * 100 : 0;
            const tradesToday = getTodayTradeCount();
            const failTag = propAccountFailedReason ? ` · FAILED (${propAccountFailedReason})` : '';
            status.textContent = `Mode ${propRules.mode.toUpperCase()} · Account $${format(simBaseCash)} · DailyLoss ${dailyLossPct.toFixed(2)}%/${propRules.dailyLossPct.toFixed(2)}% · Drawdown ${drawdownPct.toFixed(2)}%/${propRules.maxDrawdownPct.toFixed(2)}% · Trades ${tradesToday}/${propRules.maxTradesPerDay} · MaxPos ${propRules.maxOpenPositions} · MaxQty ${propRules.maxQtyPerOrder} · PosCap ${propRules.maxPositionPct}% · Consistency ${propRules.consistencyPct}%${failTag}`;
            if (failBadge) {
                if (propAccountFailedReason) {
                    failBadge.style.display = '';
                    failBadge.textContent = `Rule breach: ${propAccountFailedReason}`;
                } else {
                    failBadge.style.display = 'none';
                    failBadge.textContent = '';
                }
            }
        }

        function getDisqusShortname() {
            try {
                const stored = (localStorage.getItem(DISQUS_SHORTNAME_KEY) || '').trim();
                if (stored) return stored;
                localStorage.setItem(DISQUS_SHORTNAME_KEY, DISQUS_SHORTNAME_DEFAULT);
                return DISQUS_SHORTNAME_DEFAULT;
            } catch {
                return DISQUS_SHORTNAME_DEFAULT;
            }
        }

        function escapeHtml(text) {
            return String(text || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function getLiveChatNickname() {
            const session = localStorage.getItem('local_auth_session_v1') || '';
            if (!session || session === 'guest') return 'Guest';
            const users = JSON.parse(localStorage.getItem('local_auth_users_v1') || '[]');
            const user = users.find(u => u.email === session);
            return user?.nickname || session.split('@')[0] || 'Member';
        }

        function normalizeLiveChatMessage(msg) {
            const text = String(msg?.text || '').trim().slice(0, 300);
            if (!text) return null;
            return {
                nickname: String(msg?.nickname || 'Guest').trim() || 'Guest',
                text,
                ts: Number(msg?.ts) || Date.now(),
                symbol: normalizeSymbol(msg?.symbol || currentSymbol)
            };
        }

        function loadLiveChatHistory() {
            try {
                const raw = JSON.parse(localStorage.getItem(LIVE_CHAT_HISTORY_KEY) || '[]');
                if (!Array.isArray(raw)) return [];
                return raw.map(normalizeLiveChatMessage).filter(Boolean).slice(-LIVE_CHAT_HISTORY_MAX);
            } catch {
                return [];
            }
        }

        function saveLiveChatHistory(messages) {
            try {
                localStorage.setItem(LIVE_CHAT_HISTORY_KEY, JSON.stringify(messages.slice(-LIVE_CHAT_HISTORY_MAX)));
            } catch {
            }
        }

        function renderLiveChatMessage(msg, persist = true) {
            const box = document.getElementById('liveChatMessages');
            if (!box) return;
            const normalized = normalizeLiveChatMessage(msg);
            if (!normalized) return;
            const at = new Date(normalized.ts);
            const item = document.createElement('div');
            item.className = 'chat-item';
            item.innerHTML = `<div class="chat-meta">${escapeHtml(normalized.nickname)} · ${escapeHtml(normalized.symbol)} · ${at.toLocaleTimeString()}</div><div>${escapeHtml(normalized.text)}</div>`;
            box.appendChild(item);
            while (box.children.length > LIVE_CHAT_HISTORY_MAX) box.removeChild(box.firstChild);
            box.scrollTop = box.scrollHeight;

            if (!persist) return;
            const history = loadLiveChatHistory();
            history.push(normalized);
            saveLiveChatHistory(history);
        }

        async function initLiveChat() {
            const status = document.getElementById('liveChatStatus');
            const box = document.getElementById('liveChatMessages');
            if (!status || !box) return;

            if (liveChatChannel && liveChatClient) {
                try {
                    await liveChatClient.removeChannel(liveChatChannel);
                } catch {
                }
                liveChatChannel = null;
            }
            box.innerHTML = '';
            loadLiveChatHistory().forEach(entry => renderLiveChatMessage(entry, false));

            const supabaseUrl = localStorage.getItem(SUPABASE_URL_KEY) || '';
            const supabaseAnonKey = localStorage.getItem(SUPABASE_ANON_KEY) || '';
            if (!supabaseUrl || !supabaseAnonKey || !window.supabase) {
                status.textContent = 'Live chat off: set Supabase URL/Anon key in auth page to activate realtime.';
                return;
            }

            try {
                if (!liveChatClient) {
                    liveChatClient = window.supabase.createClient(supabaseUrl, supabaseAnonKey);
                }
                const room = 'public-live-chat-v1';
                liveChatChannel = liveChatClient
                    .channel(room)
                    .on('broadcast', { event: 'message' }, ({ payload }) => {
                        if (payload && payload.text) renderLiveChatMessage(payload);
                    })
                    .subscribe((state) => {
                        status.textContent = state === 'SUBSCRIBED'
                            ? 'Public live chat connected.'
                            : `Live chat status: ${state}`;
                    });
            } catch (err) {
                status.textContent = `Live chat failed: ${err?.message || 'init error'}`;
            }
        }

        async function sendLiveChatMessage() {
            const input = document.getElementById('liveChatInput');
            const status = document.getElementById('liveChatStatus');
            if (!input) return;
            const text = (input.value || '').trim();
            if (!text) return;
            if (!liveChatChannel) {
                if (status) status.textContent = 'Live chat is not connected.';
                return;
            }

            const payload = {
                nickname: getLiveChatNickname(),
                text: text.slice(0, 300),
                ts: Date.now(),
                symbol: normalizeSymbol(currentSymbol)
            };
            const { error } = await liveChatChannel.send({ type: 'broadcast', event: 'message', payload });
            if (error && status) {
                status.textContent = `Send failed: ${error.message}`;
                return;
            }
            input.value = '';
        }

        function initDisqusThread() {
            const statusEl = document.getElementById('disqusThreadStatus');
            const host = document.getElementById('disqus_thread');
            if (!statusEl || !host) return;

            const shortname = getDisqusShortname();
            if (!shortname) {
                statusEl.textContent = 'Disqus shortname이 설정되지 않았습니다. localStorage key(disqus_shortname_v1)에 shortname을 저장하면 댓글 기능이 활성화됩니다.';
                return;
            }

            const pageIdentifier = `symbol-${currentSymbol}`;
            const pageUrl = `${location.origin}${location.pathname}?symbol=${encodeURIComponent(currentSymbol)}`;
            window.disqus_config = function () {
                this.page.url = pageUrl;
                this.page.identifier = pageIdentifier;
                this.page.title = `Symbol Board - ${currentSymbol}`;
            };

            if (disqusLoadedForIdentifier && disqusLoadedForIdentifier !== pageIdentifier && window.DISQUS && typeof window.DISQUS.reset === 'function') {
                window.DISQUS.reset({
                    reload: true,
                    config: window.disqus_config
                });
                disqusLoadedForIdentifier = pageIdentifier;
                statusEl.textContent = `Disqus thread loaded for ${currentSymbol}.`;
                return;
            }

            if (!document.getElementById('disqus-embed-script')) {
                const script = document.createElement('script');
                script.id = 'disqus-embed-script';
                script.src = `https://${shortname}.disqus.com/embed.js`;
                script.setAttribute('data-timestamp', String(Date.now()));
                script.async = true;
                (document.head || document.body).appendChild(script);
            }
            disqusLoadedForIdentifier = pageIdentifier;
            statusEl.textContent = `Disqus thread loaded for ${currentSymbol}.`;
        }

        function applyPropPreset(mode) {
            if (!isPersistentSimSession()) {
                alert('Login required to change prop presets.');
                return;
            }
            const preset = propPresetConfigs[mode] || PROP_PRESETS_DEFAULT[mode] || PROP_PRESETS_DEFAULT.custom;
            propRules = sanitizePropRuleValues({ ...preset, mode }, mode);
            syncPropRuleUI();
            savePropRules();
            renderPropRuleStatus();
        }

        function readPropRuleInputs(targetMode = propRules.mode || 'custom') {
            return sanitizePropRuleValues({
                mode: targetMode,
                startingBalance: Number(document.getElementById('propAccountSize')?.value || 100000),
                dailyLossPct: Number(document.getElementById('propDailyLossPct')?.value || 5),
                maxDrawdownPct: Number(document.getElementById('propMaxDrawdownPct')?.value || 10),
                consistencyPct: Number(document.getElementById('propConsistencyPct')?.value || 35),
                maxTradesPerDay: Number(document.getElementById('propMaxTradesPerDay')?.value || 30),
                maxOpenPositions: Number(document.getElementById('propMaxOpenPositions')?.value || 5),
                maxQtyPerOrder: Number(document.getElementById('propMaxQtyPerOrder')?.value || 500),
                maxPositionPct: Number(document.getElementById('propMaxPositionPct')?.value || 60)
            }, targetMode);
        }

        function saveCurrentRulesToPreset() {
            if (!isPersistentSimSession()) {
                alert('Login required to edit preset values.');
                return;
            }
            const mode = propRules.mode || 'custom';
            propPresetConfigs[mode] = readPropRuleInputs(mode);
            savePropPresetConfigs();
            alert(`${mode.toUpperCase()} preset has been updated with current values.`);
        }

        function applyPropRules() {
            if (!isPersistentSimSession()) {
                alert('Login required to change prop rules.');
                return;
            }
            propRules = readPropRuleInputs(propRules.mode || 'custom');

            simBaseCash = propRules.startingBalance;
            savePropRules();
            syncPropRuleUI();
            renderPropRuleStatus();
            alert('Prop rules saved. Use Reset Account to restart with the selected account size.');
        }

        function resetPropAccount(options = {}) {
            const skipAuthCheck = !!options.skipAuthCheck;
            const silent = !!options.silent;
            const fromAdWatch = !!options.fromAdWatch;
            if (!skipAuthCheck && !isPersistentSimSession()) {
                alert('Login required to reset account.');
                return;
            }

            let resetCount = 0;
            if (!silent && !fromAdWatch) {
                resetCount = bumpManualResetClickCount();
                if (resetCount >= 3 && !consumeResetAdGrant()) {
                    alert('From the 3rd reset, ad watch is required before reset. You will be redirected now.');
                    const nextUrl = `./symbol.html?symbol=${encodeURIComponent(currentSymbol)}&ad_reset=1`;
                    location.href = `./advertise.html?flow=reset-ad&next=${encodeURIComponent(nextUrl)}`;
                    return;
                }
            }

            if (!silent && fromAdWatch) {
                try {
                    const current = Number(localStorage.getItem(getResetClickCountStorageKey()) || '3');
                    resetCount = Number.isFinite(current) ? current : 3;
                } catch {
                    resetCount = 3;
                }
            }

            simBaseCash = propRules.startingBalance;
            simCash = simBaseCash;
            simPortfolio = {};
            simTxs = [];
            propRuleDay = new Date().toISOString().slice(0, 10);
            propDailyStartEquity = simBaseCash;
            propPeakEquity = simBaseCash;
            propAccountFailedReason = '';

            savePropRules();
            savePropRuleState();
            saveSimState();
            syncPropRuleUI();
            renderSimState();
            renderEntryPriceLine();
            renderTradeMarkers();
            refreshRealtimeValuation();
            if (!silent) {
                if (resetCount >= 2) {
                    alert('Reset completed. From the 3rd attempt, ad watch is required before reset.');
                } else {
                    alert('Reset completed successfully.');
                }
            }
        }

        function blowPropAccountByRule(reason) {
            if (propAccountFailedReason) {
                return;
            }
            propAccountFailedReason = reason;
            simCash = 0;
            simPortfolio = {};
            simTxs.unshift({
                date: new Date().toLocaleString(),
                ts: Date.now(),
                symbol: currentSymbol,
                side: 'RULE-FAIL',
                qty: 0,
                price: 0
            });
            if (simTxs.length > 300) simTxs = simTxs.slice(0, 300);
            saveSimState();
            savePropRuleState();
            renderSimState();
            renderEntryPriceLine();
            renderTradeMarkers();
            refreshRealtimeValuation();
            alert(`Rule breach detected: ${reason}\n怨꾩쥖媛 利됱떆 醫낅즺?섏뿀?듬땲?? Reset Account濡??ㅼ떆 ?쒖옉?섏꽭??`);
        }

        function consumeReadResetRequest() {
            let requested = false;
            try {
                const raw = localStorage.getItem(READ_RESET_REQUEST_KEY);
                if (raw) {
                    requested = true;
                    localStorage.removeItem(READ_RESET_REQUEST_KEY);
                }
            } catch {
                return;
            }

            if (!requested) return;
            resetPropAccount({ skipAuthCheck: true, silent: true });
            alert('Read confirmation complete: demo account has been reset.');
        }

        function consumeAdResetRequest() {
            const params = new URLSearchParams(window.location.search);
            if (params.get('ad_reset') !== '1') return;

            resetPropAccount({ fromAdWatch: true });
            const url = new URL(window.location.href);
            url.searchParams.delete('ad_reset');
            history.replaceState({}, '', url.toString());
        }

        function loadSimState() {
            if (!isPersistentSimSession()) {
                simCash = simBaseCash;
                simPortfolio = {};
                simTxs = [];
                loadPropRuleState();
                return;
            }
            simCash = parseFloat(localStorage.getItem(getSimStorageKey('cash'))) || simBaseCash;
            simPortfolio = JSON.parse(localStorage.getItem(getSimStorageKey('portfolio')) || '{}');
            simTxs = JSON.parse(localStorage.getItem(getSimStorageKey('tx')) || '[]');
            loadPropRuleState();
        }

        function saveSimState() {
            if (!isPersistentSimSession()) {
                return;
            }
            localStorage.setItem(getSimStorageKey('cash'), String(simCash));
            localStorage.setItem(getSimStorageKey('portfolio'), JSON.stringify(simPortfolio));
            localStorage.setItem(getSimStorageKey('tx'), JSON.stringify(simTxs));
        }

        function getCurrentDemoPrice(symbol) {
            if (delayedQuotes[symbol] && typeof delayedQuotes[symbol].price === 'number') {
                return delayedQuotes[symbol].price;
            }
            return null;
        }

        function renderSimState() {
            const cashEl = document.getElementById('simCashDisplay');
            const totalEl = document.getElementById('simPortfolioDisplay');
            const currentPriceEl = document.getElementById('simCurrentPriceDisplay');
            const positionPnLEl = document.getElementById('simPositionPnLDisplay');
            const holdingsBody = document.getElementById('simHoldingsBody');
            const txBody = document.getElementById('simTxBody');
            const hint = document.getElementById('simTradeHint');

            const delayed = delayedQuotes[currentSymbol];
            const sourceText = delayed ? `Delayed quote ${delayed.time.toLocaleTimeString()}` : 'Demo quote';
            const currentPrice = getCurrentDemoPrice(currentSymbol);
            if (hint) {
                const persistenceText = isPersistentSimSession()
                    ? 'Logged-in mode: balance and trades are saved.'
                    : 'Guest mode: trading is available, but balance changes are not saved.';
                hint.textContent = `Order symbol: ${currentSymbol} · Current: ${currentPrice == null ? 'N/A' : '$' + format(currentPrice)} · ${sourceText} · ${persistenceText}`;
            }
            cashEl.textContent = '$' + format(simCash);
            if (currentPriceEl) currentPriceEl.textContent = currentPrice == null ? 'N/A' : '$' + format(currentPrice);

            let total = simCash;
            holdingsBody.innerHTML = '';
            const syms = Object.keys(simPortfolio);
            if (syms.length === 0) {
                holdingsBody.innerHTML = '<tr><td colspan="5" class="helper">No holdings</td></tr>';
            }

            syms.forEach(sym => {
                const item = simPortfolio[sym];
                const cur = getCurrentDemoPrice(sym);
                const pl = cur == null ? 0 : (cur - item.avgPrice) * item.qty;
                total += (cur == null ? item.avgPrice : cur) * item.qty;
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${escapeHtml(sym)}</td><td>${item.qty}</td><td>$${format(item.avgPrice)}</td><td>${cur == null ? 'N/A' : '$' + format(cur)}</td><td class="${pl >= 0 ? 'positive' : 'negative'}">$${format(pl)}</td>`;
                holdingsBody.appendChild(tr);
            });

            totalEl.textContent = '$' + format(total);

            const curHolding = simPortfolio[currentSymbol];
            if (positionPnLEl) {
                if (!curHolding || !curHolding.qty) {
                    positionPnLEl.className = 'sim-value';
                    positionPnLEl.textContent = '$0.00 (0.00%)';
                } else {
                    const curPrice = getCurrentDemoPrice(currentSymbol);
                    if (curPrice == null) {
                        positionPnLEl.className = 'sim-value';
                        positionPnLEl.textContent = 'N/A';
                        return;
                    }
                    const pnl = (curPrice - curHolding.avgPrice) * curHolding.qty;
                    const pnlPct = curHolding.avgPrice === 0 ? 0 : ((curPrice - curHolding.avgPrice) / curHolding.avgPrice) * 100;
                    positionPnLEl.className = `sim-value ${pnl >= 0 ? 'positive' : 'negative'}`;
                    positionPnLEl.textContent = `$${format(pnl)} (${format(pnlPct)}%)`;
                }
            }

            txBody.innerHTML = '';
            if (simTxs.length === 0) {
                txBody.innerHTML = '<tr><td colspan="5" class="helper">No transactions</td></tr>';
            } else {
                simTxs.forEach(t => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${escapeHtml(t.date)}</td><td>${escapeHtml(t.symbol)}</td><td>${escapeHtml(t.side)}</td><td>${t.qty}</td><td>$${format(t.price)}</td>`;
                    txBody.appendChild(tr);
                });
            }

            renderPropRuleStatus();
        }

        function executeSimTrade(orderType, side) {
            if (propAccountFailedReason) {
                alert(`怨꾩쥖媛 ?대? 醫낅즺?섏뿀?듬땲?? ${propAccountFailedReason}\nReset Account濡??ъ떆?묓븯?몄슂.`);
                return;
            }
            const qty = parseInt(document.getElementById('simQtyInput').value, 10);
            const limit = parseFloat(document.getElementById('simLimitInput').value);
            const sym = currentSymbol;
            if (!qty || qty <= 0) {
                alert('Enter a valid quantity.');
                return;
            }

            const currentPrice = getCurrentDemoPrice(sym);
            if (currentPrice == null) {
                alert('Delayed quote is not available yet. Please try again shortly.');
                return;
            }
            let execPrice = currentPrice;

            if (orderType === 'limit') {
                if (!limit || limit <= 0) {
                    alert('Enter a limit price.');
                    return;
                }
                if (side === 'buy' && currentPrice > limit) {
                    alert(`Unfilled: current price ($${format(currentPrice)}) > limit price ($${format(limit)})`);
                    return;
                }
                if (side === 'sell' && currentPrice < limit) {
                    alert(`Unfilled: current price ($${format(currentPrice)}) < limit price ($${format(limit)})`);
                    return;
                }
                execPrice = limit;
            }

            const orderNotional = execPrice * qty;
            const ruleBreach = getRuleBreachDetail({
                side,
                symbol: sym,
                qty,
                price: execPrice,
                orderNotional
            });
            if (ruleBreach) {
                blowPropAccountByRule(`${ruleBreach.code}: ${ruleBreach.message}`);
                return;
            }

            if (side === 'buy') {
                const cost = execPrice * qty;
                if (cost > simCash) {
                    alert('Insufficient cash.');
                    return;
                }
                simCash -= cost;
                if (!simPortfolio[sym]) simPortfolio[sym] = { qty: 0, avgPrice: 0 };
                const oldQty = simPortfolio[sym].qty;
                let tradeSideLabel = `BUY-${orderType.toUpperCase()}`;
                if (oldQty < 0) {
                    const shortAbs = Math.abs(oldQty);
                    if (qty < shortAbs) {
                        simPortfolio[sym].qty = oldQty + qty;
                        tradeSideLabel = `BUY-COVER-${orderType.toUpperCase()}`;
                    } else if (qty === shortAbs) {
                        delete simPortfolio[sym];
                        tradeSideLabel = `BUY-COVER-CLOSE-${orderType.toUpperCase()}`;
                    } else {
                        const longQty = qty - shortAbs;
                        simPortfolio[sym] = { qty: longQty, avgPrice: execPrice };
                        tradeSideLabel = `BUY-COVER-FLIP-${orderType.toUpperCase()}`;
                    }
                } else {
                    const newQty = oldQty + qty;
                    const oldNotional = simPortfolio[sym].avgPrice * oldQty;
                    const newNotional = oldNotional + (execPrice * qty);
                    simPortfolio[sym].avgPrice = newQty === 0 ? 0 : (newNotional / newQty);
                    simPortfolio[sym].qty = newQty;
                }
                simTxs.unshift({ date: new Date().toLocaleString(), ts: Date.now(), symbol: sym, side: tradeSideLabel, qty, price: execPrice });
            } else {
                simCash += execPrice * qty;
                if (!simPortfolio[sym]) simPortfolio[sym] = { qty: 0, avgPrice: 0 };
                const oldQty = simPortfolio[sym].qty;
                let tradeSideLabel = `SELL-${orderType.toUpperCase()}`;
                if (oldQty > 0) {
                    if (qty < oldQty) {
                        simPortfolio[sym].qty = oldQty - qty;
                    } else if (qty === oldQty) {
                        delete simPortfolio[sym];
                        tradeSideLabel = `SELL-CLOSE-${orderType.toUpperCase()}`;
                    } else {
                        const shortQty = qty - oldQty;
                        simPortfolio[sym] = { qty: -shortQty, avgPrice: execPrice };
                        tradeSideLabel = `SELL-FLIP-SHORT-${orderType.toUpperCase()}`;
                    }
                } else {
                    const oldAbs = Math.abs(oldQty);
                    const newAbs = oldAbs + qty;
                    const oldNotional = simPortfolio[sym].avgPrice * oldAbs;
                    const newNotional = oldNotional + (execPrice * qty);
                    simPortfolio[sym].avgPrice = newAbs === 0 ? 0 : (newNotional / newAbs);
                    simPortfolio[sym].qty = -newAbs;
                    tradeSideLabel = `SELL-SHORT-${orderType.toUpperCase()}`;
                }
                simTxs.unshift({ date: new Date().toLocaleString(), ts: Date.now(), symbol: sym, side: tradeSideLabel, qty, price: execPrice });
            }

            if (simTxs.length > 300) simTxs = simTxs.slice(0, 300);
            saveSimState();
            savePropRuleState();
            renderSimState();
            renderEntryPriceLine();
            appendTradeMarker(side, execPrice);
            refreshRealtimeValuation();

            const postTradeBreach = getPassiveRiskBreachDetail();
            if (postTradeBreach) {
                blowPropAccountByRule(`${postTradeBreach.code}: ${postTradeBreach.message}`);
            }
        }

        async function closeAllPositions() {
            if (propAccountFailedReason) {
                alert(`怨꾩쥖媛 ?대? 醫낅즺?섏뿀?듬땲?? ${propAccountFailedReason}\nReset Account濡??ъ떆?묓븯?몄슂.`);
                return;
            }
            const symbols = Object.keys(simPortfolio);
            if (symbols.length === 0) {
                alert('There are no positions to close.');
                return;
            }

            await refreshQuotesForSymbols(symbols);

            const now = new Date().toLocaleString();
            let closedCount = 0;
            const skipped = [];

            symbols.forEach((sym) => {
                const holding = simPortfolio[sym];
                if (!holding || !holding.qty) return;

                const currentPrice = getCurrentDemoPrice(sym);
                if (currentPrice == null) {
                    skipped.push(sym);
                    return;
                }

                const qty = holding.qty;
                const closeQty = Math.abs(qty);
                simCash += currentPrice * qty;
                delete simPortfolio[sym];
                simTxs.unshift({
                    date: now,
                    ts: Date.now(),
                    symbol: sym,
                    side: qty > 0 ? 'SELL-ALL' : 'BUY-COVER-ALL',
                    qty: closeQty,
                    price: currentPrice
                });
                if (sym === currentSymbol) {
                    appendTradeMarker(qty > 0 ? 'sell' : 'buy', currentPrice);
                }
                closedCount += 1;
            });

            if (simTxs.length > 300) simTxs = simTxs.slice(0, 300);

            saveSimState();
            renderSimState();
            renderEntryPriceLine();
            refreshRealtimeValuation();

            if (closedCount === 0) {
                alert('Close-out could not run because current quote data is unavailable. Please try again shortly.');
                return;
            }

            if (skipped.length > 0) {
                alert(`${closedCount} positions closed (excluding ${skipped.length} symbols with unavailable quotes).`);
                return;
            }

            alert(`${closedCount} positions closed successfully.`);
        }

        function setSymbol(symbol) {
            currentSymbol = normalizeSymbol(symbol);
            symbolInput.value = currentSymbol;
            boardTitle.textContent = `${currentSymbol} Board`;
            const url = new URL(window.location.href);
            url.searchParams.set('symbol', currentSymbol);
            history.replaceState({}, '', url.toString());
            renderPosts();
            updateChartsForSymbol(currentSymbol);
            initDisqusThread();
        }

        function setCategory(category) {
            currentCategory = category;
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.category === category);
            });
            renderPosts();
        }

        function renderCategories() {
            categoryTabs.innerHTML = '';
            CATEGORIES.forEach(category => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'tab';
                btn.dataset.category = category;
                btn.textContent = category;
                btn.addEventListener('click', () => setCategory(category));
                categoryTabs.appendChild(btn);
            });
            setCategory(currentCategory);
        }

        function renderPosts() {
            postList.innerHTML = '';
            const filtered = posts.filter(p => p.symbol === currentSymbol && p.category === currentCategory);
            postCount.textContent = `${filtered.length} posts`;
            if (filtered.length === 0) {
                postList.innerHTML = '<div class="post"><p>No posts yet.</p></div>';
                return;
            }
            filtered.forEach((post, index) => {
                const card = document.createElement('div');
                card.className = 'post';
                card.innerHTML = `
                    <h3>${escapeHtml(post.title)}</h3>
                    <div class="meta">${escapeHtml(post.author || 'Anonymous')} · ${escapeHtml(post.date)}</div>
                    <p>${escapeHtml(post.body)}</p>
                    <div class="actions">
                        <button class="ghost" data-index="${index}">Delete</button>
                    </div>
                `;
                postList.appendChild(card);
            });
        }

        function savePosts() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(posts));
        }

        function getModerationState() {
            try {
                return JSON.parse(localStorage.getItem(MODERATION_STATE_KEY) || '{}');
            } catch {
                return {};
            }
        }

        function saveModerationState(state) {
            localStorage.setItem(MODERATION_STATE_KEY, JSON.stringify(state || {}));
        }

        function normalizeModerationText(text) {
            return (text || '').toLowerCase().replace(/\s+/g, ' ').trim();
        }

        function normalizeCompactText(text) {
            return (text || '')
                .toLowerCase()
                .replace(/[^a-z0-9]/g, '')
                .trim();
        }

        function checkCommunityViolation(text) {
            const lowered = normalizeModerationText(text);
            const compact = normalizeCompactText(text);
            if (!lowered) return null;

            const adPatterns = [
                /signal\s*room|paid\s*room|member\s*recruit|investment\s*solicitation|promotion|advertisement|principal\s*guarantee|profit\s*guarantee/,
                /telegram|open\s*chat|kakao|line\s*id|dm\s*me|contact\s*me/,
                /vip\s*room|pick\s*sharing|high\s*return\s*proof|investment\s*secret|investment\s*consulting/
            ];

            const contactPatterns = [
                /\b\d{2,3}[-\s]?\d{3,4}[-\s]?\d{4}\b/,
                /@[a-z0-9_.-]+\.[a-z]{2,}/,
                /t\.me\//,
                /open\.kakao\.com\//,
                /kakao\.com\//,
                /discord\.gg\//,
                /instagram\.com\//
            ];

            const sexualPatterns = [
                /porn|adult\s*stream|nude\s*chat|escort|sex\s*trade|explicit|one\s*night/,
                /sexual\s*content|sexual\s*act/
            ];

            const abusePatterns = [
                /idiot|moron|stupid|fuck\s*off|die|kill\s*yourself/,
                /racist|sexist|hate\s*speech|slur/
            ];

            const illegalPatterns = [
                /drug|marijuana|meth|cocaine|illegal\s*gambling|betting\s*site/,
                /piracy|hacking|account\s*trading|fraud/
            ];

            const scamPatterns = [
                /principal\s*guarantee|guaranteed\s*profit|100\s*%\s*profit|high\s*return\s*guarantee/,
                /advance\s*payment|deposit\s*inducement|no\s*refund|proxy\s*investment/
            ];

            const compactBlockedWords = [
                'signalroom', 'paidroom', 'openchat', 'telegram', 'kakao', 'principalguarantee', 'profitguarantee',
                'escort', 'explicit', 'prostitution', 'porn', 'idiot', 'moron', 'drug', 'illegalgambling'
            ];

            const urlCount = (lowered.match(/https?:\/\//g) || []).length;
            if (urlCount >= 2) {
                return 'Too many external links (spam-like)';
            }

            if (/(.)\1{9,}/.test(lowered)) {
                return 'Repeated spam characters';
            }

            if (adPatterns.some(regex => regex.test(lowered))) {
                return 'Personal advertising/promotion or external solicitation';
            }
            if (contactPatterns.some(regex => regex.test(lowered))) {
                return 'Contact info or external channel solicitation';
            }
            if (sexualPatterns.some(regex => regex.test(lowered))) {
                return 'Sexual/explicit content';
            }
            if (abusePatterns.some(regex => regex.test(lowered))) {
                return 'Abusive/hateful/violent language';
            }
            if (illegalPatterns.some(regex => regex.test(lowered))) {
                return 'Illegal activity related content';
            }
            if (scamPatterns.some(regex => regex.test(lowered))) {
                return 'Scam-like / exaggerated profit claim';
            }
            if (compactBlockedWords.some(word => compact.includes(word))) {
                return 'Blocked evasive expression';
            }
            return null;
        }

        function checkPostingBan() {
            const state = getModerationState();
            const until = Number(state.bannedUntil || 0);
            if (!until || Date.now() >= until) return null;
            return new Date(until);
        }

        function registerViolation(reason) {
            const state = getModerationState();
            const strikes = Number(state.strikes || 0) + 1;
            const next = {
                strikes,
                lastReason: reason,
                lastAt: new Date().toISOString(),
                bannedUntil: state.bannedUntil || 0
            };

            if (strikes >= MODERATION_MAX_STRIKES) {
                next.bannedUntil = Date.now() + MODERATION_BAN_MS;
                next.strikes = 0;
            }

            saveModerationState(next);
            return next;
        }

        postForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const blockedUntil = checkPostingBan();
            if (blockedUntil) {
                alert(`Posting is restricted due to repeated policy violations. Unban time: ${blockedUntil.toLocaleString()}`);
                return;
            }

            const title = document.getElementById('postTitle').value.trim();
            const author = document.getElementById('postAuthor').value.trim();
            const body = document.getElementById('postBody').value.trim();
            const moderationTarget = `${title}\n${author}\n${body}`;

            if (currentCategory === 'Free Board') {
                const violation = checkCommunityViolation(moderationTarget);
                if (violation) {
                    const state = registerViolation(violation);
                    if (state.bannedUntil && Date.now() < Number(state.bannedUntil)) {
                        alert(`Blocked content detected (${violation}). Posting is blocked and a 24-hour restriction has been applied due to repeated violations.`);
                        return;
                    }
                    const remain = MODERATION_MAX_STRIKES - Number(state.strikes || 0);
                    alert(`Blocked content detected (${violation}). Posting was blocked. Repeated violations may lead to a ban. Remaining warnings: ${remain}`);
                    return;
                }
            }

            const post = {
                symbol: currentSymbol,
                category: currentCategory,
                title,
                author,
                body,
                date: new Date().toLocaleString()
            };
            posts.unshift(post);
            savePosts();
            postForm.reset();
            renderPosts();
        });

        postList.addEventListener('click', (event) => {
            if (event.target.matches('button[data-index]')) {
                const index = parseInt(event.target.dataset.index, 10);
                const filtered = posts.filter(p => p.symbol === currentSymbol && p.category === currentCategory);
                const postToRemove = filtered[index];
                posts = posts.filter(p => p !== postToRemove);
                savePosts();
                renderPosts();
            }
        });

        goSymbol.addEventListener('click', () => {
            const symbol = symbolInput.value.trim();
            if (!symbol) return;
            setSymbol(symbol);
        });

        const liveChatSendBtn = document.getElementById('liveChatSendBtn');
        const liveChatInput = document.getElementById('liveChatInput');
        if (liveChatSendBtn) {
            liveChatSendBtn.addEventListener('click', () => {
                sendLiveChatMessage();
            });
        }
        if (liveChatInput) {
            liveChatInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    sendLiveChatMessage();
                }
            });
        }

        document.getElementById('exportPosts').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(posts, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'symbol-posts.json';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        });

        document.getElementById('importPosts').addEventListener('click', () => {
            document.getElementById('postImportFile').click();
        });

        document.getElementById('postImportFile').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const imported = JSON.parse(reader.result);
                    if (Array.isArray(imported)) {
                        posts = imported;
                        savePosts();
                        renderPosts();
                    }
                } catch (err) {
                    alert('Import failed: please check JSON format.');
                }
            };
            reader.readAsText(file);
        });

        function initFromQuery() {
            const params = new URLSearchParams(window.location.search);
            const symbol = params.get('symbol');
            if (symbol) {
                setSymbol(symbol);
            } else {
                setSymbol(currentSymbol);
            }
        }

        document.getElementById('simMarketBuyBtn').addEventListener('click', () => executeSimTrade('market', 'buy'));
        document.getElementById('simMarketSellBtn').addEventListener('click', () => executeSimTrade('market', 'sell'));
        document.getElementById('simLimitBuyBtn').addEventListener('click', () => executeSimTrade('limit', 'buy'));
        document.getElementById('simLimitSellBtn').addEventListener('click', () => executeSimTrade('limit', 'sell'));
        document.getElementById('simCloseAllBtn').addEventListener('click', closeAllPositions);
        document.getElementById('propPresetCustomBtn').addEventListener('click', () => {
            applyPropPreset('custom');
        });
        document.getElementById('propPresetEodBtn').addEventListener('click', () => applyPropPreset('eod'));
        document.getElementById('propPresetTmddBtn').addEventListener('click', () => applyPropPreset('tmdd'));
        document.getElementById('propApplyRulesBtn').addEventListener('click', applyPropRules);
        document.getElementById('propResetAccountBtn').addEventListener('click', resetPropAccount);
        document.getElementById('propSavePresetBtn').addEventListener('click', saveCurrentRulesToPreset);

        loadPropPresetConfigs();
        loadPropRules();
        syncPropRuleUI();
        loadSimState();
        initLightweightChart();
        renderCategories();
        initFromQuery();
        initLiveChat();
        initDisqusThread();
        consumeAdResetRequest();
        consumeReadResetRequest();
        if (realtimeQuoteTimer) clearInterval(realtimeQuoteTimer);
        realtimeQuoteTimer = setInterval(refreshRealtimeValuation, 10000);
    </script>
    <script src="./analytics.js"></script>
    <script src="./legal-consent.js"></script>
    <script src="./assistant-widget.js"></script>
    <script src="./userback.js"></script>
</body>
</html>

