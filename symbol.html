<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ì¢…ëª© ê²Œì‹œíŒ - Smart Investment Tips</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --ink: #0f172a;
            --muted: #64748b;
            --panel: #ffffff;
            --bg: #f5f7fb;
            --accent: #2563eb;
            --accent-soft: #dbeafe;
            --line: #e2e8f0;
            --shadow: 0 16px 30px rgba(15, 23, 42, 0.12);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", sans-serif;
            background: radial-gradient(circle at top, #eef2ff, #f5f7fb 60%);
            color: var(--ink);
            line-height: 1.6;
        }

        nav {
            background: var(--panel);
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        nav .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        nav .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent);
        }

        nav a {
            text-decoration: none;
            color: var(--ink);
            font-weight: 600;
            margin-left: 16px;
        }

        .hero {
            max-width: 1200px;
            margin: 30px auto 0;
            padding: 0 20px;
        }

        .hero-card {
            background: linear-gradient(135deg, #1d4ed8, #38bdf8);
            color: #fff;
            border-radius: 18px;
            padding: 30px;
            box-shadow: var(--shadow);
        }

        .hero-card h1 {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .hero-card p { opacity: 0.9; }

        .content {
            max-width: 1200px;
            margin: 24px auto 80px;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }

        .panel {
            background: var(--panel);
            border-radius: 16px;
            padding: 22px;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
        }

        .panel h2 {
            font-size: 20px;
            margin-bottom: 6px;
        }

        .panel p.desc {
            color: var(--muted);
            font-size: 14px;
            margin-bottom: 14px;
        }

        .row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 12px;
        }

        label {
            display: block;
            font-size: 13px;
            color: var(--muted);
            margin-bottom: 6px;
        }

        input, textarea, button {
            width: 100%;
            border-radius: 10px;
            border: 1px solid var(--line);
            padding: 10px 12px;
            font-size: 14px;
            font-family: inherit;
        }

        textarea { min-height: 110px; resize: vertical; }

        button.primary {
            background: var(--accent);
            color: #fff;
            border: none;
            font-weight: 600;
            cursor: pointer;
        }

        button.ghost {
            background: transparent;
            border: 1px solid var(--line);
            color: var(--ink);
            cursor: pointer;
        }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        #categoryTabs {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .tab {
            width: 100%;
            padding: 8px 14px;
            border-radius: 10px;
            border: 1px solid var(--line);
            background: #fff;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: var(--muted);
            text-align: left;
        }

        .tab.active {
            background: var(--accent-soft);
            color: var(--accent);
            border-color: #bfdbfe;
        }

        .post-list {
            display: grid;
            gap: 12px;
        }

        .post {
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 14px;
            background: #fff;
        }

        .post h3 {
            font-size: 16px;
            margin-bottom: 6px;
        }

        .meta {
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 8px;
        }

        .actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .helper {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px;
        }

        .chart-wrap {
            border: 1px solid var(--line);
            border-radius: 12px;
            overflow: hidden;
            background: #fff;
        }

        #lightweightChart {
            width: 100%;
            height: 300px;
        }

        .chart-meta {
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px;
        }

        .indicator-toolbar {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid var(--line);
            border-radius: 10px;
            background: #f8fafc;
            display: grid;
            gap: 8px;
        }

        .frame-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .frame-btn {
            width: auto;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 12px;
            background: #fff;
            border: 1px solid var(--line);
            color: var(--muted);
            cursor: pointer;
        }

        .frame-btn.active {
            background: var(--accent-soft);
            border-color: #bfdbfe;
            color: var(--accent);
            font-weight: 700;
        }

        .indicator-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 6px;
        }

        .indicator-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--ink);
        }

        .indicator-item input {
            width: auto;
            margin: 0;
            padding: 0;
        }

        .indicator-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .indicator-subcharts {
            display: grid;
            gap: 8px;
            margin-top: 10px;
        }

        .subchart-box {
            border: 1px solid var(--line);
            border-radius: 10px;
            background: #fff;
            overflow: hidden;
        }

        .subchart-title {
            font-size: 12px;
            color: var(--muted);
            padding: 6px 10px;
            border-bottom: 1px solid var(--line);
            background: #f8fafc;
        }

        .subchart-canvas {
            width: 100%;
            height: 130px;
        }

        .indicator-value-card {
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 8px;
            background: #fff;
        }

        .indicator-value-card .name {
            font-size: 11px;
            color: var(--muted);
        }

        .indicator-value-card .val {
            font-size: 14px;
            font-weight: 700;
        }

        .sim-grid-mini {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .sim-box {
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 10px;
            background: #fff;
        }

        .sim-value {
            font-size: 20px;
            font-weight: 700;
        }

        .sim-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .sim-table-wrap {
            overflow: auto;
            max-height: 220px;
            border: 1px solid var(--line);
            border-radius: 10px;
            margin-top: 10px;
        }

        .sim-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .sim-table th,
        .sim-table td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid var(--line);
        }

        .positive { color: #16a34a; }
        .negative { color: #dc2626; }

        #chartPanel,
        #simulatorPanel,
        #symbolPanel {
            grid-column: 1 / -1;
        }

        #chartPanel { order: 1; }
        #simulatorPanel { order: 2; }
        #categoryPanel { order: 3; grid-column: 1; }
        #writePanel { order: 4; grid-column: 2; }
        #postsPanel { order: 5; grid-column: 2; }
        #symbolPanel { order: 6; }

        @media (max-width: 720px) {
            nav .container { padding: 1rem; }
            .hero-card { padding: 22px; }
            .content {
                grid-template-columns: 1fr;
            }
            #chartPanel,
            #simulatorPanel,
            #categoryPanel,
            #writePanel,
            #postsPanel,
            #symbolPanel {
                grid-column: 1;
            }
        }
    </style>
</head>
<body>
    <nav>
        <div class="container">
            <div class="logo">ğŸ’° Smart Investment Tips</div>
            <div>
                <a href="./index.html">Home</a>
                <a href="./market.html">Markets</a>
                <a href="./journal.html">Journal</a>
                <a href="./news.html">News</a>
                <a href="./advertise.html">Advertise</a>
                <a href="./contact.html">Contact</a>
                <a href="./auth.html">Login</a>
            </div>
        </div>
    </nav>

    <section class="hero">
        <div class="hero-card">
            <h1 id="boardTitle">ì¢…ëª© ê²Œì‹œíŒ</h1>
            <p>ì¢…ëª©ë³„ë¡œ ë§¤ë§¤ì¼ì§€ì™€ ììœ ê²Œì‹œíŒ ê¸€ì„ ì‘ì„±í•  ìˆ˜ ìˆì–´ìš”. ëª¨ë“  ê¸€ì€ ë¸Œë¼ìš°ì €ì— ì €ì¥ë©ë‹ˆë‹¤.</p>
        </div>
    </section>

    <section class="content">
        <div class="panel" id="symbolPanel">
            <h2>ì¢…ëª© ì„ íƒ</h2>
            <p class="desc">ì¢…ëª©ì„ ì…ë ¥í•˜ë©´ í•´ë‹¹ ì¢…ëª© ê²Œì‹œíŒìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.</p>
            <div class="row">
                <div>
                    <label for="symbolInput">ì¢…ëª©/í‹°ì»¤</label>
                    <input id="symbolInput" type="text" placeholder="AAPL, 005930" />
                </div>
                <div>
                    <label>&nbsp;</label>
                    <button class="primary" id="goSymbol">ê²Œì‹œíŒ ì—´ê¸°</button>
                </div>
            </div>
            <div class="helper">ì˜ˆ: AAPL, TSLA, 005930</div>
        </div>

        <div class="panel" id="categoryPanel">
            <h2>ì¹´í…Œê³ ë¦¬</h2>
            <p class="desc">ì›í•˜ëŠ” ì¹´í…Œê³ ë¦¬ë¥¼ ëˆŒëŸ¬ ê¸€ì„ ì‘ì„±í•˜ê±°ë‚˜ í™•ì¸í•˜ì„¸ìš”.</p>
            <div class="tabs" id="categoryTabs"></div>
            <div class="helper">ì¹´í…Œê³ ë¦¬: ë§¤ë§¤ì¼ì§€ Â· ììœ ê²Œì‹œíŒ</div>
        </div>

        <div class="panel" id="chartPanel">
            <h2 id="chartTitle">AAPL ì°¨íŠ¸</h2>
            <p class="desc">ì¢…ëª© ë³€ê²½ ì‹œ ì°¨íŠ¸ê°€ ìë™ìœ¼ë¡œ ë°”ë€ë‹ˆë‹¤. ë§¤ë§¤ì¼ì§€ ì‘ì„± ì „ì— ê°€ê²© íë¦„ì„ ì°¸ê³ í•˜ì„¸ìš”.</p>

            <div class="chart-wrap">
                <div id="lightweightChart"></div>
            </div>
            <div class="chart-meta" id="lightweightSource">ì¶œì²˜: Lightweight Chartsâ„¢ by TradingView (í‘œì‹œ ë°ì´í„°: ì§€ì—° ì‹œì„¸ ìš°ì„ , ì‹¤íŒ¨ ì‹œ ë°ëª¨ê°’)</div>
            <div class="chart-meta" id="chartStatusMessage"></div>

            <div class="indicator-toolbar">
                <div class="frame-toolbar" id="frameToolbar"></div>
                <div class="helper" style="margin-top:0;">ì¸ê¸° ì§€í‘œ 10ì¢… (ìì²´ ê³„ì‚°): MA5 Â· MA20 Â· MA60 Â· EMA12 Â· EMA26 Â· VWAP Â· Bollinger Bands Â· RSI Â· MACD Â· Stochastic</div>
                <div class="indicator-list" id="indicatorToggleList"></div>
            </div>
            <div class="indicator-values" id="indicatorValueBoard"></div>
            <div class="indicator-subcharts" id="indicatorSubcharts">
                <div class="subchart-box">
                    <div class="subchart-title">RSI (14)</div>
                    <div id="rsiChart" class="subchart-canvas"></div>
                </div>
                <div class="subchart-box">
                    <div class="subchart-title">MACD (12, 26, 9)</div>
                    <div id="macdChart" class="subchart-canvas"></div>
                </div>
                <div class="subchart-box">
                    <div class="subchart-title">Stochastic (14, 3)</div>
                    <div id="stochChart" class="subchart-canvas"></div>
                </div>
            </div>

        </div>

        <div class="panel" id="simulatorPanel">
            <h2>Virtual Trading Simulator</h2>
            <p class="desc">í˜„ì¬ ì°¨íŠ¸ ì¢…ëª© ê¸°ì¤€ìœ¼ë¡œ ì¦‰ì‹œ ê°€ìƒë§¤ë§¤ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤. ë³„ë„ ì‹œë®¬ë ˆì´í„° í˜ì´ì§€ ì—†ì´ ì—¬ê¸°ì„œ ì‹¤í–‰ë©ë‹ˆë‹¤.</p>

            <div class="sim-grid-mini">
                <div class="sim-box">
                    <div class="helper">í˜„ê¸ˆ ì”ê³ </div>
                    <div class="sim-value" id="simCashDisplay">$100,000.00</div>
                </div>
                <div class="sim-box">
                    <div class="helper">ì´ í‰ê°€ê¸ˆì•¡</div>
                    <div class="sim-value" id="simPortfolioDisplay">$100,000.00</div>
                </div>
                <div class="sim-box">
                    <div class="helper">í˜„ì¬ê°€ (ì„ íƒ ì¢…ëª©)</div>
                    <div class="sim-value" id="simCurrentPriceDisplay">$0.00</div>
                </div>
                <div class="sim-box">
                    <div class="helper">í¬ì§€ì…˜ ì†ìµ (+/-)</div>
                    <div class="sim-value" id="simPositionPnLDisplay">$0.00 (0.00%)</div>
                </div>
            </div>

            <div class="row">
                <div>
                    <label for="simQtyInput">ìˆ˜ëŸ‰</label>
                    <input id="simQtyInput" type="number" min="1" placeholder="Qty" />
                </div>
                <div>
                    <label for="simLimitInput">ì§€ì •ê°€</label>
                    <input id="simLimitInput" type="number" min="0.01" step="0.01" placeholder="Limit Price" />
                </div>
            </div>

            <div class="sim-controls">
                <button id="simMarketBuyBtn" class="primary" type="button">ì‹œì¥ê°€ ë§¤ìˆ˜</button>
                <button id="simMarketSellBtn" class="ghost" type="button">ì‹œì¥ê°€ ë§¤ë„</button>
                <button id="simLimitBuyBtn" class="primary" type="button">ì§€ì •ê°€ ë§¤ìˆ˜</button>
                <button id="simLimitSellBtn" class="ghost" type="button">ì§€ì •ê°€ ë§¤ë„</button>
                <button id="simCloseAllBtn" class="ghost" type="button">ëª¨ë“  í¬ì§€ì…˜ ì¢…ë£Œ</button>
            </div>
            <div class="helper" id="simTradeHint">ì£¼ë¬¸ì€ í˜„ì¬ ì„ íƒ ì¢…ëª©ì— ëŒ€í•´ ì‹¤í–‰ë©ë‹ˆë‹¤.</div>

            <h3 style="margin-top:14px; font-size:16px;">ë³´ìœ  ì¢…ëª©</h3>
            <div class="sim-table-wrap">
                <table class="sim-table">
                    <thead><tr><th>Symbol</th><th>Qty</th><th>Avg</th><th>Current</th><th>P/L</th></tr></thead>
                    <tbody id="simHoldingsBody"></tbody>
                </table>
            </div>

            <h3 style="margin-top:14px; font-size:16px;">ì²´ê²° ë‚´ì—­</h3>
            <div class="sim-table-wrap">
                <table class="sim-table">
                    <thead><tr><th>Date</th><th>Symbol</th><th>Side</th><th>Qty</th><th>Price</th></tr></thead>
                    <tbody id="simTxBody"></tbody>
                </table>
            </div>
        </div>

        <div class="panel" id="writePanel">
            <h2>ìƒˆ ê¸€ ì‘ì„±</h2>
            <p class="desc">ì„ íƒëœ ì¹´í…Œê³ ë¦¬ì— ê¸€ì´ ì €ì¥ë©ë‹ˆë‹¤.</p>
            <form id="postForm">
                <div class="row">
                    <div>
                        <label for="postTitle">ì œëª©</label>
                        <input id="postTitle" type="text" required />
                    </div>
                    <div>
                        <label for="postAuthor">ë‹‰ë„¤ì„</label>
                        <input id="postAuthor" type="text" placeholder="ìµëª…" />
                    </div>
                </div>
                <div>
                    <label for="postBody">ë‚´ìš©</label>
                    <textarea id="postBody" required placeholder="ììœ ë¡­ê²Œ ì‘ì„±í•˜ì„¸ìš”"></textarea>
                </div>
                <div class="actions">
                    <button class="primary" type="submit">ê¸€ ì €ì¥</button>
                    <button class="ghost" type="button" id="exportPosts">ë‚´ë³´ë‚´ê¸°</button>
                    <button class="ghost" type="button" id="importPosts">ê°€ì ¸ì˜¤ê¸°</button>
                    <input id="postImportFile" type="file" accept="application/json" style="display:none" />
                </div>
                <div class="helper">ììœ ê²Œì‹œíŒ ìš´ì˜ì •ì±…: ê°œì¸ ê´‘ê³ /ì—°ë½ì²˜ ìœ ë„/ì„±ì  ë°œì–¸ ê¸ˆì§€ Â· ë°˜ë³µ ìœ„ë°˜ ì‹œ ê²Œì‹œ ì œí•œ(ë°´)ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. <a href="./community-rules.html" target="_blank" rel="noopener">ì •ì±… ë³´ê¸°</a></div>
                <div class="helper">ë¸Œë¼ìš°ì €ì—ë§Œ ì €ì¥ë©ë‹ˆë‹¤. ë‹¤ë¥¸ ê¸°ê¸°ì™€ ê³µìœ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>
            </form>
        </div>

        <div class="panel" id="postsPanel">
            <h2>ê²Œì‹œê¸€</h2>
            <p class="desc" id="postCount">0ê±´</p>
            <div class="post-list" id="postList"></div>
        </div>
    </section>

    <script>
        const CATEGORIES = ['ë§¤ë§¤ì¼ì§€', 'ììœ ê²Œì‹œíŒ'];
        const STORAGE_KEY = 'symbol_posts_v1';

        const boardTitle = document.getElementById('boardTitle');
        const symbolInput = document.getElementById('symbolInput');
        const goSymbol = document.getElementById('goSymbol');
        const categoryTabs = document.getElementById('categoryTabs');
        const postForm = document.getElementById('postForm');
        const postList = document.getElementById('postList');
        const postCount = document.getElementById('postCount');
        const SIM_INITIAL_CASH = 100000;
        const MODERATION_STATE_KEY = 'community_moderation_state_v1';
        const MODERATION_MAX_STRIKES = 3;
        const MODERATION_BAN_MS = 24 * 60 * 60 * 1000;

        let currentSymbol = 'AAPL';
        let currentCategory = CATEGORIES[0];
        let posts = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        let lwChart;
        let lwSeries;
        let lwSeriesType = 'area';
        let lwEntryLine = null;
        let lwTradeMarkers = [];
        let lwMainData = [];
        let indicatorSeriesMap = {};
        let rsiChart;
        let macdChart;
        let stochChart;
        let rsiSeries;
        let rsiMidSeries;
        let macdLineSeries;
        let macdSignalSeries;
        let macdHistSeries;
        let stochKSeries;
        let stochDSeries;
        let stochMidSeries;
        let realtimeQuoteTimer = null;
        let realtimeRefreshInFlight = false;
        let simCash = SIM_INITIAL_CASH;
        let simPortfolio = {};
        let simTxs = [];

        const FRAME_OPTIONS = [
            { key: '1D', label: '1D', range: '1d', interval: '5m' },
            { key: '5D', label: '5D', range: '5d', interval: '15m' },
            { key: '1M', label: '1M', range: '1mo', interval: '1h' },
            { key: '3M', label: '3M', range: '3mo', interval: '1d' },
            { key: '6M', label: '6M', range: '6mo', interval: '1d' },
            { key: '1Y', label: '1Y', range: '1y', interval: '1wk' }
        ];
        let currentFrame = '3M';
        const HISTORY_CACHE_PREFIX = 'delayed_history_v1';
        const QUOTE_CACHE_PREFIX = 'delayed_quote_v1';
        const FAST_RENDER_DEADLINE_MS = 1200;
        const FETCH_TIMEOUT_MS = 2200;

        const DEMO_BASE_PRICE = {
            KOSPI: 2580.12,
            KOSDAQ: 865.34,
            NASDAQ: 16520.22,
            SP500: 5150.44,
            DOW: 38800.10,
            AAPL: 187.22,
            BTCUSD: 96000.00
        };

        const DELAYED_QUOTE_SYMBOLS = {
            KOSPI: '^KS11',
            KOSDAQ: '^KQ11',
            NASDAQ: '^IXIC',
            SP500: '^GSPC',
            DOW: '^DJI',
            AAPL: 'AAPL',
            BTCUSD: 'BTC-USD'
        };

        let delayedQuotes = {};
        let delayedHistoryBySymbol = {};

        const INDICATOR_DEFINITIONS = [
            { key: 'ma5', label: 'MA 5', type: 'overlay', defaultOn: false, color: '#f59e0b' },
            { key: 'ma20', label: 'MA 20', type: 'overlay', defaultOn: false, color: '#8b5cf6' },
            { key: 'ma60', label: 'MA 60', type: 'overlay', defaultOn: false, color: '#06b6d4' },
            { key: 'ema12', label: 'EMA 12', type: 'overlay', defaultOn: false, color: '#10b981' },
            { key: 'ema26', label: 'EMA 26', type: 'overlay', defaultOn: false, color: '#ef4444' },
            { key: 'vwap', label: 'VWAP', type: 'overlay', defaultOn: false, color: '#0ea5e9' },
            { key: 'bbands', label: 'Bollinger', type: 'overlay-multi', defaultOn: false, color: '#6366f1' },
            { key: 'rsi', label: 'RSI 14', type: 'value', defaultOn: true, color: '#334155' },
            { key: 'macd', label: 'MACD', type: 'value', defaultOn: true, color: '#334155' },
            { key: 'stoch', label: 'Stochastic', type: 'value', defaultOn: true, color: '#334155' }
        ];

        let indicatorEnabled = INDICATOR_DEFINITIONS.reduce((acc, item) => {
            acc[item.key] = !!item.defaultOn;
            return acc;
        }, {});

        function format(value) {
            return Number(value || 0).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        function getCurrentFrameConfig() {
            return FRAME_OPTIONS.find(opt => opt.key === currentFrame) || FRAME_OPTIONS[3];
        }

        function getHistoryCacheKey(symbol) {
            return `${HISTORY_CACHE_PREFIX}_${normalizeSymbol(symbol)}_${currentFrame}`;
        }

        function getQuoteCacheKey(symbol) {
            return `${QUOTE_CACHE_PREFIX}_${normalizeSymbol(symbol)}`;
        }

        function loadHistoryFromCache(symbol) {
            try {
                const raw = localStorage.getItem(getHistoryCacheKey(symbol));
                if (!raw) return [];
                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) return [];
                return parsed;
            } catch {
                return [];
            }
        }

        function saveHistoryToCache(symbol, history) {
            try {
                localStorage.setItem(getHistoryCacheKey(symbol), JSON.stringify(history));
            } catch {
                // ignore quota/cache errors
            }
        }

        function loadQuoteFromCache(symbol) {
            try {
                const raw = localStorage.getItem(getQuoteCacheKey(symbol));
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed.price !== 'number') return null;
                return {
                    price: Number(parsed.price),
                    prevClose: typeof parsed.prevClose === 'number' ? Number(parsed.prevClose) : null,
                    time: parsed.time ? new Date(parsed.time) : new Date()
                };
            } catch {
                return null;
            }
        }

        function saveQuoteToCache(symbol, quote) {
            try {
                localStorage.setItem(getQuoteCacheKey(symbol), JSON.stringify({
                    price: quote.price,
                    prevClose: quote.prevClose,
                    time: quote.time instanceof Date ? quote.time.toISOString() : new Date().toISOString()
                }));
            } catch {
                // ignore quota/cache errors
            }
        }

        function warmStartSymbolData(symbol) {
            if (!delayedQuotes[symbol]) {
                const cachedQuote = loadQuoteFromCache(symbol);
                if (cachedQuote) {
                    delayedQuotes[symbol] = cachedQuote;
                }
            }

            if (!delayedHistoryBySymbol[symbol] || delayedHistoryBySymbol[symbol].length === 0) {
                const cachedHistory = loadHistoryFromCache(symbol);
                if (cachedHistory.length > 0) {
                    delayedHistoryBySymbol[symbol] = cachedHistory;
                } else {
                    const quoteHistory = buildQuoteBasedHistory(symbol);
                    if (quoteHistory.length > 0) {
                        delayedHistoryBySymbol[symbol] = quoteHistory;
                    }
                }
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function fetchJsonWithFallback(url) {
            const targets = [
                url,
                `https://corsproxy.io/?${encodeURIComponent(url)}`,
                `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
            ];

            const jobs = targets.map(target => (async () => {
                const controller = new AbortController();
                const timer = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
                try {
                    const res = await fetch(target, { cache: 'no-store', signal: controller.signal });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.json();
                } finally {
                    clearTimeout(timer);
                }
            })());

            try {
                return await Promise.any(jobs);
            } catch (err) {
                throw err || new Error('Delayed data fetch failed');
            }
        }

        function renderFrameButtons() {
            const root = document.getElementById('frameToolbar');
            if (!root) return;
            root.innerHTML = '';

            FRAME_OPTIONS.forEach(opt => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = `frame-btn ${opt.key === currentFrame ? 'active' : ''}`;
                btn.textContent = opt.label;
                btn.addEventListener('click', async () => {
                    if (currentFrame === opt.key) return;
                    currentFrame = opt.key;
                    renderFrameButtons();
                    const statusEl = document.getElementById('chartStatusMessage');
                    if (statusEl) statusEl.textContent = 'ì„ íƒ í”„ë ˆì„ ë°ì´í„° ë¡œë”© ì¤‘...';
                    await refreshHistoryForSymbols([currentSymbol]);
                    applyMainSeriesData(currentSymbol);
                });
                root.appendChild(btn);
            });
        }

        function normalizeSymbol(rawSymbol) {
            const normalized = String(rawSymbol || '').trim().toUpperCase();
            if (normalized === '^KS11' || normalized === 'KS11') return 'KOSPI';
            if (normalized === '^KQ11' || normalized === 'KQ11') return 'KOSDAQ';
            if (normalized === '^GSPC' || normalized === '.GSPC') return 'SP500';
            if (normalized === '^DJI') return 'DOW';
            return normalized || 'AAPL';
        }

        function resolveYahooSymbols(symbol) {
            const normalized = normalizeSymbol(symbol);
            if (DELAYED_QUOTE_SYMBOLS[normalized]) return [DELAYED_QUOTE_SYMBOLS[normalized]];

            if (/^[0-9]{6}$/.test(normalized)) {
                return [`${normalized}.KS`, `${normalized}.KQ`, normalized];
            }

            if (normalized.includes(':')) {
                const parts = normalized.split(':');
                if (parts[1]) return [parts[1]];
            }

            return [normalized];
        }

        function symbolSeed(symbol) {
            let hash = 0;
            for (let i = 0; i < symbol.length; i++) {
                hash = ((hash << 5) - hash) + symbol.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash);
        }

        function getDayIndex(date) {
            return Math.floor(date.getTime() / 86400000);
        }

        function seededUnit(seed, step) {
            const x = Math.sin((seed * 0.0001) + (step * 12.9898)) * 43758.5453;
            return x - Math.floor(x);
        }

        function generateLightweightData(symbol) {
            const live = delayedHistoryBySymbol[symbol] || [];
            if (live.length > 0) return live;
            return loadHistoryFromCache(symbol);
        }

        function toLineData(values) {
            return lwMainData.map((point, idx) => (values[idx] == null ? null : { time: point.time, value: Number(values[idx].toFixed(2)) })).filter(Boolean);
        }

        function calcSma(period, source) {
            const out = Array(source.length).fill(null);
            let sum = 0;
            for (let i = 0; i < source.length; i++) {
                sum += source[i];
                if (i >= period) sum -= source[i - period];
                if (i >= period - 1) out[i] = sum / period;
            }
            return out;
        }

        function calcEma(period, source) {
            if (!source.length) return [];
            const out = Array(source.length).fill(null);
            const alpha = 2 / (period + 1);
            let ema = source[0];
            out[0] = ema;
            for (let i = 1; i < source.length; i++) {
                ema = (source[i] * alpha) + (ema * (1 - alpha));
                out[i] = ema;
            }
            return out;
        }

        function calcStd(source, period) {
            const out = Array(source.length).fill(null);
            for (let i = period - 1; i < source.length; i++) {
                const window = source.slice(i - period + 1, i + 1);
                const mean = window.reduce((a, b) => a + b, 0) / period;
                const variance = window.reduce((a, b) => a + ((b - mean) ** 2), 0) / period;
                out[i] = Math.sqrt(variance);
            }
            return out;
        }

        function calcVwap(source) {
            const out = Array(source.length).fill(null);
            let pv = 0;
            let vv = 0;
            source.forEach((row, idx) => {
                pv += row.value * row.volume;
                vv += row.volume;
                out[idx] = vv === 0 ? row.value : pv / vv;
            });
            return out;
        }

        function calcRsiSeries(period, source) {
            const out = Array(source.length).fill(null);
            if (source.length <= period) return out;

            let gain = 0;
            let loss = 0;
            for (let i = 1; i <= period; i++) {
                const diff = source[i] - source[i - 1];
                if (diff >= 0) gain += diff;
                else loss -= diff;
            }

            let avgGain = gain / period;
            let avgLoss = loss / period;
            out[period] = avgLoss === 0 ? 100 : (100 - (100 / (1 + (avgGain / avgLoss))));

            for (let i = period + 1; i < source.length; i++) {
                const diff = source[i] - source[i - 1];
                const g = diff > 0 ? diff : 0;
                const l = diff < 0 ? -diff : 0;
                avgGain = ((avgGain * (period - 1)) + g) / period;
                avgLoss = ((avgLoss * (period - 1)) + l) / period;
                out[i] = avgLoss === 0 ? 100 : (100 - (100 / (1 + (avgGain / avgLoss))));
            }

            return out;
        }

        function calcMacdSeries(source) {
            const ema12 = calcEma(12, source);
            const ema26 = calcEma(26, source);
            const macd = source.map((_, idx) => (ema12[idx] == null || ema26[idx] == null) ? null : (ema12[idx] - ema26[idx]));
            const valid = macd.map(v => v == null ? 0 : v);
            const signal = calcEma(9, valid);
            const hist = macd.map((v, idx) => (v == null || signal[idx] == null) ? null : (v - signal[idx]));
            return {
                macd,
                signal,
                hist
            };
        }

        function calcStochasticSeries(period, smooth, data) {
            const k = Array(data.length).fill(null);
            for (let i = period - 1; i < data.length; i++) {
                const window = data.slice(i - period + 1, i + 1);
                const high = Math.max(...window.map(x => x.high));
                const low = Math.min(...window.map(x => x.low));
                k[i] = high === low ? 50 : (((data[i].value - low) / (high - low)) * 100);
            }

            const kSafe = k.map(v => v == null ? 50 : v);
            const d = calcSma(smooth, kSafe);
            return { k, d };
        }

        function addHistogramSeriesCompat(chart, options) {
            if (typeof chart.addHistogramSeries === 'function') return chart.addHistogramSeries(options);
            if (typeof chart.addSeries === 'function' && window.LightweightCharts.HistogramSeries) {
                return chart.addSeries(window.LightweightCharts.HistogramSeries, options);
            }
            return null;
        }

        function addLineSeriesForChart(chart, options) {
            if (typeof chart.addLineSeries === 'function') return chart.addLineSeries(options);
            if (typeof chart.addSeries === 'function' && window.LightweightCharts.LineSeries) {
                return chart.addSeries(window.LightweightCharts.LineSeries, options);
            }
            return null;
        }

        function initIndicatorSubcharts() {
            if (!window.LightweightCharts) return;

            const baseOptions = {
                layout: { background: { color: '#ffffff' }, textColor: '#64748b' },
                grid: { vertLines: { color: '#f1f5f9' }, horzLines: { color: '#f1f5f9' } },
                width: document.getElementById('lightweightChart').clientWidth,
                height: 130,
                rightPriceScale: { borderColor: '#e2e8f0' },
                timeScale: { borderColor: '#e2e8f0' }
            };

            const rsiRoot = document.getElementById('rsiChart');
            const macdRoot = document.getElementById('macdChart');
            const stochRoot = document.getElementById('stochChart');
            if (!rsiRoot || !macdRoot || !stochRoot) return;

            rsiChart = LightweightCharts.createChart(rsiRoot, baseOptions);
            macdChart = LightweightCharts.createChart(macdRoot, baseOptions);
            stochChart = LightweightCharts.createChart(stochRoot, baseOptions);

            rsiSeries = addLineSeriesForChart(rsiChart, { color: '#7c3aed', lineWidth: 2 });
            rsiMidSeries = addLineSeriesForChart(rsiChart, { color: '#94a3b8', lineWidth: 1, lineStyle: 2 });

            macdLineSeries = addLineSeriesForChart(macdChart, { color: '#2563eb', lineWidth: 2 });
            macdSignalSeries = addLineSeriesForChart(macdChart, { color: '#f97316', lineWidth: 2 });
            macdHistSeries = addHistogramSeriesCompat(macdChart, { color: '#94a3b8' });

            stochKSeries = addLineSeriesForChart(stochChart, { color: '#16a34a', lineWidth: 2 });
            stochDSeries = addLineSeriesForChart(stochChart, { color: '#dc2626', lineWidth: 2 });
            stochMidSeries = addLineSeriesForChart(stochChart, { color: '#94a3b8', lineWidth: 1, lineStyle: 2 });
        }

        function renderIndicatorSubcharts(rsiSeriesData, macdSeriesData, stochSeriesData) {
            if (!rsiChart || !macdChart || !stochChart) return;

            const midline = lwMainData.map(p => ({ time: p.time, value: 50 }));
            const zeroLine = lwMainData.map(p => ({ time: p.time, value: 0 }));

            if (rsiSeries) rsiSeries.setData(indicatorEnabled.rsi ? toLineData(rsiSeriesData) : []);
            if (rsiMidSeries) rsiMidSeries.setData(indicatorEnabled.rsi ? midline : []);

            if (macdLineSeries) macdLineSeries.setData(indicatorEnabled.macd ? toLineData(macdSeriesData.macd) : []);
            if (macdSignalSeries) macdSignalSeries.setData(indicatorEnabled.macd ? toLineData(macdSeriesData.signal) : []);
            if (macdHistSeries) {
                macdHistSeries.setData(indicatorEnabled.macd
                    ? lwMainData.map((p, idx) => ({
                        time: p.time,
                        value: macdSeriesData.hist[idx] == null ? 0 : Number(macdSeriesData.hist[idx].toFixed(4)),
                        color: (macdSeriesData.hist[idx] || 0) >= 0 ? '#16a34a' : '#dc2626'
                    }))
                    : []);
            }

            if (stochKSeries) stochKSeries.setData(indicatorEnabled.stoch ? toLineData(stochSeriesData.k) : []);
            if (stochDSeries) stochDSeries.setData(indicatorEnabled.stoch ? toLineData(stochSeriesData.d) : []);
            if (stochMidSeries) stochMidSeries.setData(indicatorEnabled.stoch ? midline : []);

            rsiChart.timeScale().fitContent();
            macdChart.timeScale().fitContent();
            stochChart.timeScale().fitContent();
        }

        function addLineSeriesCompat(options) {
            if (typeof lwChart.addLineSeries === 'function') return lwChart.addLineSeries(options);
            if (typeof lwChart.addSeries === 'function' && window.LightweightCharts.LineSeries) {
                return lwChart.addSeries(window.LightweightCharts.LineSeries, options);
            }
            return null;
        }

        function createPrimarySeries(symbol) {
            const useCandle = true;
            if (useCandle) {
                if (typeof lwChart.addCandlestickSeries === 'function') {
                    lwSeriesType = 'candlestick';
                    return lwChart.addCandlestickSeries({
                        upColor: '#16a34a',
                        downColor: '#dc2626',
                        borderVisible: false,
                        wickUpColor: '#16a34a',
                        wickDownColor: '#dc2626'
                    });
                }
                if (typeof lwChart.addSeries === 'function' && window.LightweightCharts.CandlestickSeries) {
                    lwSeriesType = 'candlestick';
                    return lwChart.addSeries(window.LightweightCharts.CandlestickSeries, {
                        upColor: '#16a34a',
                        downColor: '#dc2626',
                        borderVisible: false,
                        wickUpColor: '#16a34a',
                        wickDownColor: '#dc2626'
                    });
                }
            }

            const areaOptions = {
                lineColor: '#2563eb',
                topColor: 'rgba(37, 99, 235, 0.35)',
                bottomColor: 'rgba(37, 99, 235, 0.06)',
                lineWidth: 2
            };

            if (typeof lwChart.addAreaSeries === 'function') {
                lwSeriesType = 'area';
                return lwChart.addAreaSeries(areaOptions);
            }
            if (typeof lwChart.addSeries === 'function' && window.LightweightCharts.AreaSeries) {
                lwSeriesType = 'area';
                return lwChart.addSeries(window.LightweightCharts.AreaSeries, areaOptions);
            }

            return null;
        }

        function ensureIndicatorSeries() {
            if (!lwChart || !lwSeries) return;
            if (indicatorSeriesMap.ma5) return;

            indicatorSeriesMap.ma5 = addLineSeriesCompat({ color: '#f59e0b', lineWidth: 1 });
            indicatorSeriesMap.ma20 = addLineSeriesCompat({ color: '#8b5cf6', lineWidth: 1 });
            indicatorSeriesMap.ma60 = addLineSeriesCompat({ color: '#06b6d4', lineWidth: 1 });
            indicatorSeriesMap.ema12 = addLineSeriesCompat({ color: '#10b981', lineWidth: 1 });
            indicatorSeriesMap.ema26 = addLineSeriesCompat({ color: '#ef4444', lineWidth: 1 });
            indicatorSeriesMap.vwap = addLineSeriesCompat({ color: '#0ea5e9', lineWidth: 1 });
            indicatorSeriesMap.bbUpper = addLineSeriesCompat({ color: '#6366f1', lineWidth: 1, lineStyle: 2 });
            indicatorSeriesMap.bbMid = addLineSeriesCompat({ color: '#6366f1', lineWidth: 1 });
            indicatorSeriesMap.bbLower = addLineSeriesCompat({ color: '#6366f1', lineWidth: 1, lineStyle: 2 });
        }

        function renderIndicatorBoard(values) {
            const board = document.getElementById('indicatorValueBoard');
            if (!board) return;

            const rows = [];
            const push = (name, value) => {
                rows.push(`<div class="indicator-value-card"><div class="name">${name}</div><div class="val">${value}</div></div>`);
            };

            if (indicatorEnabled.ma5) push('MA5', `$${format(values.ma5)}`);
            if (indicatorEnabled.ma20) push('MA20', `$${format(values.ma20)}`);
            if (indicatorEnabled.ma60) push('MA60', `$${format(values.ma60)}`);
            if (indicatorEnabled.ema12) push('EMA12', `$${format(values.ema12)}`);
            if (indicatorEnabled.ema26) push('EMA26', `$${format(values.ema26)}`);
            if (indicatorEnabled.vwap) push('VWAP', `$${format(values.vwap)}`);
            if (indicatorEnabled.bbands) push('Bollinger', `$${format(values.bbLower)} / $${format(values.bbMid)} / $${format(values.bbUpper)}`);
            if (indicatorEnabled.rsi) push('RSI(14)', `${format(values.rsi)}`);
            if (indicatorEnabled.macd) push('MACD', `${format(values.macd)} / ${format(values.macdSignal)} / ${format(values.macdHist)}`);
            if (indicatorEnabled.stoch) push('Stochastic', `${format(values.stoch)}`);

            board.innerHTML = rows.join('');
        }

        function renderIndicators() {
            ensureIndicatorSeries();
            if (!lwMainData.length) return;

            const closes = lwMainData.map(x => x.value);
            const ma5 = calcSma(5, closes);
            const ma20 = calcSma(20, closes);
            const ma60 = calcSma(60, closes);
            const ema12 = calcEma(12, closes);
            const ema26 = calcEma(26, closes);
            const vwap = calcVwap(lwMainData);
            const std20 = calcStd(closes, 20);
            const bbMid = ma20;
            const bbUpper = bbMid.map((v, idx) => (v == null || std20[idx] == null) ? null : (v + (2 * std20[idx])));
            const bbLower = bbMid.map((v, idx) => (v == null || std20[idx] == null) ? null : (v - (2 * std20[idx])));

            const bindSeries = (key, values) => {
                const series = indicatorSeriesMap[key];
                if (!series) return;
                series.setData(indicatorEnabled[key] ? toLineData(values) : []);
            };

            bindSeries('ma5', ma5);
            bindSeries('ma20', ma20);
            bindSeries('ma60', ma60);
            bindSeries('ema12', ema12);
            bindSeries('ema26', ema26);
            bindSeries('vwap', vwap);
            indicatorSeriesMap.bbUpper?.setData(indicatorEnabled.bbands ? toLineData(bbUpper) : []);
            indicatorSeriesMap.bbMid?.setData(indicatorEnabled.bbands ? toLineData(bbMid) : []);
            indicatorSeriesMap.bbLower?.setData(indicatorEnabled.bbands ? toLineData(bbLower) : []);

            const rsiSeriesData = calcRsiSeries(14, closes);
            const macdSeriesData = calcMacdSeries(closes);
            const stochSeriesData = calcStochasticSeries(14, 3, lwMainData);
            renderIndicatorSubcharts(rsiSeriesData, macdSeriesData, stochSeriesData);
            const last = closes.length - 1;
            renderIndicatorBoard({
                ma5: ma5[ma5.length - 1],
                ma20: ma20[ma20.length - 1],
                ma60: ma60[ma60.length - 1],
                ema12: ema12[ema12.length - 1],
                ema26: ema26[ema26.length - 1],
                vwap: vwap[vwap.length - 1],
                bbUpper: bbUpper[bbUpper.length - 1],
                bbMid: bbMid[bbMid.length - 1],
                bbLower: bbLower[bbLower.length - 1],
                rsi: rsiSeriesData[last],
                macd: macdSeriesData.macd[last],
                macdSignal: macdSeriesData.signal[last],
                macdHist: macdSeriesData.hist[last],
                stoch: stochSeriesData.k[last]
            });
        }

        function applyMainSeriesData(symbol) {
            const nextData = generateLightweightData(symbol);
            const statusEl = document.getElementById('chartStatusMessage');

            if (!nextData.length) {
                if (statusEl) statusEl.textContent = 'ì°¨íŠ¸ ë°ì´í„° ìˆ˜ì‹  ì‹¤íŒ¨: ì§€ì—° ì‹œì„¸ ì‘ë‹µì´ ì—†ìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬/CORS ì œí•œ ë˜ëŠ” ê³µê¸‰ì‚¬ ì‘ë‹µ ì§€ì—°ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
                renderIndicators();
                return;
            }

            lwMainData = nextData;
            if (statusEl) statusEl.textContent = '';
            if (lwSeries) {
                if (lwSeriesType === 'candlestick') {
                    lwSeries.setData(lwMainData.map((x, idx) => {
                        const open = idx === 0 ? x.value : lwMainData[idx - 1].value;
                        return {
                            time: x.time,
                            open: Number(open.toFixed(2)),
                            high: x.high,
                            low: x.low,
                            close: x.value
                        };
                    }));
                } else {
                    lwSeries.setData(lwMainData.map(x => ({ time: x.time, value: x.value })));
                }
            }
            renderIndicators();
        }

        function getDemoPrice(symbol) {
            return null;
        }

        async function fetchDelayedQuote(symbol) {
            const candidates = resolveYahooSymbols(symbol);
            if (!candidates.length) return;

            const quoteRequest = (async () => {
                const url = `https://query1.finance.yahoo.com/v7/finance/quote?symbols=${encodeURIComponent(candidates.join(','))}`;
                const data = await fetchJsonWithFallback(url);
                const results = data?.quoteResponse?.result || [];
                const item = results.find(r => typeof r?.regularMarketPrice === 'number');
                if (!item || typeof item.regularMarketPrice !== 'number') throw new Error('Delayed quote payload error');
                return {
                    price: Number(item.regularMarketPrice),
                    prevClose: typeof item.regularMarketPreviousClose === 'number' ? Number(item.regularMarketPreviousClose) : null,
                    time: typeof item.regularMarketTime === 'number' ? new Date(item.regularMarketTime * 1000) : new Date()
                };
            })();

            const chartMetaRequests = candidates.map(yahooSymbol => (async () => {
                const url = `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(yahooSymbol)}?range=5d&interval=1d`;
                const data = await fetchJsonWithFallback(url);
                const result = data?.chart?.result?.[0];
                const meta = result?.meta || {};
                const closes = result?.indicators?.quote?.[0]?.close || [];
                const validCloses = closes.filter(v => typeof v === 'number');
                const marketPrice = typeof meta.regularMarketPrice === 'number'
                    ? Number(meta.regularMarketPrice)
                    : Number(validCloses[validCloses.length - 1]);
                if (!Number.isFinite(marketPrice)) throw new Error('No market price in chart meta');
                const prevClose = typeof meta.chartPreviousClose === 'number'
                    ? Number(meta.chartPreviousClose)
                    : (validCloses.length > 1 ? Number(validCloses[validCloses.length - 2]) : marketPrice);
                return {
                    price: marketPrice,
                    prevClose: Number.isFinite(prevClose) ? prevClose : null,
                    time: new Date()
                };
            })());

            const quote = await Promise.any([quoteRequest, ...chartMetaRequests]);
            delayedQuotes[symbol] = quote;
            saveQuoteToCache(symbol, delayedQuotes[symbol]);
        }

        async function fetchDelayedHistory(symbol) {
            const symbolCandidates = resolveYahooSymbols(symbol);
            if (!symbolCandidates.length) return;

            const frame = getCurrentFrameConfig();
            const candidates = [
                { range: frame.range, interval: frame.interval },
                { range: '1mo', interval: '1h' },
                { range: '3mo', interval: '1d' },
                { range: '6mo', interval: '1d' }
            ];

            const parseHistory = (data) => {
                const result = data?.chart?.result?.[0];
                const timestamps = result?.timestamp || [];
                const quote = result?.indicators?.quote?.[0] || {};
                const opens = quote.open || [];
                const highs = quote.high || [];
                const lows = quote.low || [];
                const closes = quote.close || [];
                const volumes = quote.volume || [];

                const history = [];
                for (let i = 0; i < timestamps.length; i++) {
                    const close = closes[i];
                    if (close == null) continue;
                    const open = opens[i] == null ? close : opens[i];
                    const high = highs[i] == null ? Math.max(open, close) : highs[i];
                    const low = lows[i] == null ? Math.min(open, close) : lows[i];
                    history.push({
                        time: Number(timestamps[i]),
                        value: Number(close),
                        high: Number(high),
                        low: Number(low),
                        volume: Math.max(0, Number(volumes[i] || 0))
                    });
                }
                return history;
            };

            const requestFor = (yahooSymbol, candidate) => (async () => {
                const url = `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(yahooSymbol)}?range=${candidate.range}&interval=${candidate.interval}`;
                const data = await fetchJsonWithFallback(url);
                const history = parseHistory(data);
                if (!history.length) throw new Error('Empty history');
                return history;
            })();

            const primaryRequests = symbolCandidates.map(yahooSymbol => requestFor(yahooSymbol, candidates[0]));
            try {
                const primary = await Promise.any(primaryRequests);
                delayedHistoryBySymbol[symbol] = primary;
                saveHistoryToCache(symbol, primary);
                return;
            } catch {
                // fallback tier
            }

            const fallbackRequests = [];
            for (const yahooSymbol of symbolCandidates) {
                for (let i = 1; i < candidates.length; i++) {
                    fallbackRequests.push(requestFor(yahooSymbol, candidates[i]));
                }
            }

            if (!fallbackRequests.length) return;

            try {
                const fallbackHistory = await Promise.any(fallbackRequests);
                delayedHistoryBySymbol[symbol] = fallbackHistory;
                saveHistoryToCache(symbol, fallbackHistory);
            } catch {
                // keep previous/cached data
            }
        }

        function buildQuoteBasedHistory(symbol) {
            const quote = delayedQuotes[symbol];
            if (!quote || typeof quote.price !== 'number') return [];

            const now = quote.time instanceof Date ? quote.time : new Date();
            const todayTs = Math.floor(now.getTime() / 1000);
            const prevTs = todayTs - 86400;
            const prevClose = typeof quote.prevClose === 'number' ? quote.prevClose : quote.price;
            const high = Math.max(quote.price, prevClose);
            const low = Math.min(quote.price, prevClose);

            return [
                {
                    time: prevTs,
                    value: Number(prevClose),
                    high: Number(high),
                    low: Number(low),
                    volume: 0
                },
                {
                    time: todayTs,
                    value: Number(quote.price),
                    high: Number(high),
                    low: Number(low),
                    volume: 0
                }
            ];
        }

        async function refreshQuotesForSymbols(symbols) {
            const uniqueSymbols = Array.from(new Set(symbols.filter(Boolean)));
            if (uniqueSymbols.length === 0) return;

            await Promise.allSettled(uniqueSymbols.map(async (symbol) => {
                try {
                    await fetchDelayedQuote(symbol);
                } catch (err) {
                    // fallback keeps deterministic demo price
                }
            }));
        }

        async function refreshHistoryForSymbols(symbols) {
            const uniqueSymbols = Array.from(new Set(symbols.filter(Boolean)));
            if (uniqueSymbols.length === 0) return;

            await Promise.allSettled(uniqueSymbols.map(async (symbol) => {
                try {
                    await fetchDelayedHistory(symbol);
                } catch (err) {
                    // keep last successful/cached history to avoid blank chart flicker
                }
            }));
        }

        async function refreshRealtimeValuation() {
            if (realtimeRefreshInFlight) return;
            realtimeRefreshInFlight = true;

            const portfolioSymbols = Object.keys(simPortfolio);
            warmStartSymbolData(currentSymbol);
            try {
                const quotePromise = refreshQuotesForSymbols([currentSymbol, ...portfolioSymbols]);
                const historyPromise = refreshHistoryForSymbols([currentSymbol]);

                await Promise.race([historyPromise, sleep(FAST_RENDER_DEADLINE_MS)]);

                if (!delayedHistoryBySymbol[currentSymbol] || delayedHistoryBySymbol[currentSymbol].length === 0) {
                    await Promise.race([quotePromise, sleep(FAST_RENDER_DEADLINE_MS)]);
                    delayedHistoryBySymbol[currentSymbol] = buildQuoteBasedHistory(currentSymbol);
                }

                if (lwSeries) applyMainSeriesData(currentSymbol);

                await Promise.allSettled([quotePromise, historyPromise]);
                if (lwSeries) applyMainSeriesData(currentSymbol);

                const source = document.getElementById('lightweightSource');
                if (source && (!delayedHistoryBySymbol[currentSymbol] || delayedHistoryBySymbol[currentSymbol].length === 0)) {
                    source.textContent = 'ì¶œì²˜: Lightweight Chartsâ„¢ by TradingView (ì§€ì—° íˆìŠ¤í† ë¦¬ ìˆ˜ì‹  ì‹¤íŒ¨ Â· í˜„ì¬ ì§€ì—°ì‹œì„¸ë§Œ í‘œì‹œ ê°€ëŠ¥)';
                }

                renderEntryPriceLine();
                renderTradeMarkers();
                renderSimState();
            } finally {
                realtimeRefreshInFlight = false;
            }
        }

        function renderIndicatorToggles() {
            const root = document.getElementById('indicatorToggleList');
            if (!root) return;
            root.innerHTML = '';

            INDICATOR_DEFINITIONS.forEach(ind => {
                const label = document.createElement('label');
                label.className = 'indicator-item';
                label.innerHTML = `<input type="checkbox" data-indicator="${ind.key}" ${indicatorEnabled[ind.key] ? 'checked' : ''} /><span>${ind.label}</span>`;
                root.appendChild(label);
            });

            root.querySelectorAll('input[data-indicator]').forEach(input => {
                input.addEventListener('change', (event) => {
                    const key = event.target.dataset.indicator;
                    indicatorEnabled[key] = !!event.target.checked;
                    renderIndicators();
                });
            });
        }

        function renderEntryPriceLine() {
            if (!lwSeries) return;

            if (lwEntryLine) {
                lwSeries.removePriceLine(lwEntryLine);
                lwEntryLine = null;
            }

            const holding = simPortfolio[currentSymbol];
            if (!holding || !holding.qty) return;

            lwEntryLine = lwSeries.createPriceLine({
                price: Number(holding.avgPrice.toFixed(2)),
                color: '#dc2626',
                lineWidth: 2,
                lineStyle: 2,
                axisLabelVisible: true,
                title: 'í‰ê·  ì§„ì…ê°€'
            });
        }

        function renderTradeMarkers() {
            if (!lwSeries || typeof lwSeries.setMarkers !== 'function') return;
            lwSeries.setMarkers(lwTradeMarkers);
        }

        function appendTradeMarker(side, price) {
            const lastBar = lwMainData[lwMainData.length - 1];
            const markerTime = lastBar ? lastBar.time : Math.floor(Date.now() / 1000);
            lwTradeMarkers.push({
                time: markerTime,
                position: side === 'buy' ? 'belowBar' : 'aboveBar',
                color: side === 'buy' ? '#16a34a' : '#dc2626',
                shape: side === 'buy' ? 'arrowUp' : 'arrowDown',
                text: `${side.toUpperCase()} $${format(price)}`
            });
            if (lwTradeMarkers.length > 200) {
                lwTradeMarkers = lwTradeMarkers.slice(lwTradeMarkers.length - 200);
            }
            renderTradeMarkers();
        }

        function initLightweightChart() {
            const root = document.getElementById('lightweightChart');
            if (!root || !window.LightweightCharts) return;
            lwChart = LightweightCharts.createChart(root, {
                width: root.clientWidth,
                height: 300,
                layout: {
                    background: { color: '#ffffff' },
                    textColor: '#334155'
                },
                grid: {
                    vertLines: { color: '#f1f5f9' },
                    horzLines: { color: '#f1f5f9' }
                }
            });

            lwSeries = createPrimarySeries(currentSymbol);
            if (!lwSeries) {
                document.getElementById('lightweightSource').textContent = 'ì°¨íŠ¸ ë¡œë”© ì‹¤íŒ¨: Lightweight Charts ë²„ì „ í˜¸í™˜ ë¬¸ì œ';
                return;
            }

            applyMainSeriesData(currentSymbol);
            renderFrameButtons();
            renderIndicatorToggles();
            initIndicatorSubcharts();
            renderIndicators();
            window.addEventListener('resize', () => {
                lwChart.applyOptions({ width: root.clientWidth });
                const width = root.clientWidth;
                if (rsiChart) rsiChart.applyOptions({ width });
                if (macdChart) macdChart.applyOptions({ width });
                if (stochChart) stochChart.applyOptions({ width });
            });
        }

        function updateChartsForSymbol(symbol) {
            document.getElementById('chartTitle').textContent = `${symbol} ì°¨íŠ¸`;
            const targetSeriesType = 'candlestick';
            if (lwSeries && lwSeriesType !== targetSeriesType && lwChart.removeSeries) {
                lwChart.removeSeries(lwSeries);
                lwSeries = createPrimarySeries(symbol);
            }
            warmStartSymbolData(symbol);
            if (lwSeries) applyMainSeriesData(symbol);
            const source = document.getElementById('lightweightSource');
            if (source) {
                source.textContent = 'ì¶œì²˜: Lightweight Chartsâ„¢ by TradingView (ì „ ì¢…ëª© ìº”ë“¤ ëª¨ë“œ, ì§€ì—° ì‹œì„¸ ìš°ì„ )';
            }
            renderEntryPriceLine();
            renderTradeMarkers();
            renderSimState();
            refreshRealtimeValuation();
        }

        function getSimSessionKey() {
            return localStorage.getItem('local_auth_session_v1') || 'guest';
        }

        function getSimStorageKey(suffix) {
            return `merged_sim_v1_${getSimSessionKey()}_${suffix}`;
        }

        function loadSimState() {
            simCash = parseFloat(localStorage.getItem(getSimStorageKey('cash'))) || SIM_INITIAL_CASH;
            simPortfolio = JSON.parse(localStorage.getItem(getSimStorageKey('portfolio')) || '{}');
            simTxs = JSON.parse(localStorage.getItem(getSimStorageKey('tx')) || '[]');
        }

        function saveSimState() {
            localStorage.setItem(getSimStorageKey('cash'), String(simCash));
            localStorage.setItem(getSimStorageKey('portfolio'), JSON.stringify(simPortfolio));
            localStorage.setItem(getSimStorageKey('tx'), JSON.stringify(simTxs));
        }

        function getCurrentDemoPrice(symbol) {
            if (delayedQuotes[symbol] && typeof delayedQuotes[symbol].price === 'number') {
                return delayedQuotes[symbol].price;
            }
            return null;
        }

        function renderSimState() {
            const cashEl = document.getElementById('simCashDisplay');
            const totalEl = document.getElementById('simPortfolioDisplay');
            const currentPriceEl = document.getElementById('simCurrentPriceDisplay');
            const positionPnLEl = document.getElementById('simPositionPnLDisplay');
            const holdingsBody = document.getElementById('simHoldingsBody');
            const txBody = document.getElementById('simTxBody');
            const hint = document.getElementById('simTradeHint');

            const delayed = delayedQuotes[currentSymbol];
            const sourceText = delayed ? `ì§€ì—°ì‹œì„¸ ${delayed.time.toLocaleTimeString()}` : 'ë°ëª¨ì‹œì„¸';
            const currentPrice = getCurrentDemoPrice(currentSymbol);
            if (hint) hint.textContent = `ì£¼ë¬¸ ëŒ€ìƒ ì¢…ëª©: ${currentSymbol} Â· í˜„ì¬ê°€: ${currentPrice == null ? 'N/A' : '$' + format(currentPrice)} Â· ${sourceText}`;
            cashEl.textContent = '$' + format(simCash);
            if (currentPriceEl) currentPriceEl.textContent = currentPrice == null ? 'N/A' : '$' + format(currentPrice);

            let total = simCash;
            holdingsBody.innerHTML = '';
            const syms = Object.keys(simPortfolio);
            if (syms.length === 0) {
                holdingsBody.innerHTML = '<tr><td colspan="5" class="helper">No holdings</td></tr>';
            }

            syms.forEach(sym => {
                const item = simPortfolio[sym];
                const cur = getCurrentDemoPrice(sym);
                const pl = cur == null ? 0 : (cur - item.avgPrice) * item.qty;
                total += (cur == null ? item.avgPrice : cur) * item.qty;
                const tr = document.createElement('tr');
                tr.innerHTML = `<td>${sym}</td><td>${item.qty}</td><td>$${format(item.avgPrice)}</td><td>${cur == null ? 'N/A' : '$' + format(cur)}</td><td class="${pl >= 0 ? 'positive' : 'negative'}">$${format(pl)}</td>`;
                holdingsBody.appendChild(tr);
            });

            totalEl.textContent = '$' + format(total);

            const curHolding = simPortfolio[currentSymbol];
            if (positionPnLEl) {
                if (!curHolding || !curHolding.qty) {
                    positionPnLEl.className = 'sim-value';
                    positionPnLEl.textContent = '$0.00 (0.00%)';
                } else {
                    const curPrice = getCurrentDemoPrice(currentSymbol);
                    if (curPrice == null) {
                        positionPnLEl.className = 'sim-value';
                        positionPnLEl.textContent = 'N/A';
                        return;
                    }
                    const pnl = (curPrice - curHolding.avgPrice) * curHolding.qty;
                    const pnlPct = curHolding.avgPrice === 0 ? 0 : ((curPrice - curHolding.avgPrice) / curHolding.avgPrice) * 100;
                    positionPnLEl.className = `sim-value ${pnl >= 0 ? 'positive' : 'negative'}`;
                    positionPnLEl.textContent = `$${format(pnl)} (${format(pnlPct)}%)`;
                }
            }

            txBody.innerHTML = '';
            if (simTxs.length === 0) {
                txBody.innerHTML = '<tr><td colspan="5" class="helper">No transactions</td></tr>';
            } else {
                simTxs.forEach(t => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${t.date}</td><td>${t.symbol}</td><td>${t.side}</td><td>${t.qty}</td><td>$${format(t.price)}</td>`;
                    txBody.appendChild(tr);
                });
            }
        }

        function executeSimTrade(orderType, side) {
            const qty = parseInt(document.getElementById('simQtyInput').value, 10);
            const limit = parseFloat(document.getElementById('simLimitInput').value);
            const sym = currentSymbol;
            if (!qty || qty <= 0) {
                alert('ìˆ˜ëŸ‰ì„ ì˜¬ë°”ë¥´ê²Œ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            const currentPrice = getCurrentDemoPrice(sym);
            if (currentPrice == null) {
                alert('ì§€ì—° ì‹œì„¸ë¥¼ ì•„ì§ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.');
                return;
            }
            let execPrice = currentPrice;

            if (orderType === 'limit') {
                if (!limit || limit <= 0) {
                    alert('ì§€ì •ê°€ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                    return;
                }
                if (side === 'buy' && currentPrice > limit) {
                    alert(`ë¯¸ì²´ê²°: í˜„ì¬ê°€($${format(currentPrice)}) > ì§€ì •ê°€($${format(limit)})`);
                    return;
                }
                if (side === 'sell' && currentPrice < limit) {
                    alert(`ë¯¸ì²´ê²°: í˜„ì¬ê°€($${format(currentPrice)}) < ì§€ì •ê°€($${format(limit)})`);
                    return;
                }
                execPrice = limit;
            }

            if (side === 'buy') {
                const cost = execPrice * qty;
                if (cost > simCash) {
                    alert('í˜„ê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤.');
                    return;
                }
                simCash -= cost;
                if (!simPortfolio[sym]) simPortfolio[sym] = { qty: 0, avgPrice: 0 };
                const oldQty = simPortfolio[sym].qty;
                const newQty = oldQty + qty;
                simPortfolio[sym].avgPrice = ((simPortfolio[sym].avgPrice * oldQty) + (execPrice * qty)) / newQty;
                simPortfolio[sym].qty = newQty;
                simTxs.unshift({ date: new Date().toLocaleString(), symbol: sym, side: `BUY-${orderType.toUpperCase()}`, qty, price: execPrice });
            } else {
                if (!simPortfolio[sym] || simPortfolio[sym].qty < qty) {
                    alert('ë³´ìœ  ìˆ˜ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.');
                    return;
                }
                simCash += execPrice * qty;
                simPortfolio[sym].qty -= qty;
                if (simPortfolio[sym].qty === 0) delete simPortfolio[sym];
                simTxs.unshift({ date: new Date().toLocaleString(), symbol: sym, side: `SELL-${orderType.toUpperCase()}`, qty, price: execPrice });
            }

            if (simTxs.length > 300) simTxs = simTxs.slice(0, 300);
            saveSimState();
            renderSimState();
            renderEntryPriceLine();
            appendTradeMarker(side, execPrice);
            refreshRealtimeValuation();
        }

        async function closeAllPositions() {
            const symbols = Object.keys(simPortfolio);
            if (symbols.length === 0) {
                alert('ì¢…ë£Œí•  í¬ì§€ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            await refreshQuotesForSymbols(symbols);

            const now = new Date().toLocaleString();
            let closedCount = 0;
            const skipped = [];

            symbols.forEach((sym) => {
                const holding = simPortfolio[sym];
                if (!holding || !holding.qty) return;

                const currentPrice = getCurrentDemoPrice(sym);
                if (currentPrice == null) {
                    skipped.push(sym);
                    return;
                }

                const qty = holding.qty;
                simCash += currentPrice * qty;
                delete simPortfolio[sym];
                simTxs.unshift({ date: now, symbol: sym, side: 'SELL-ALL', qty, price: currentPrice });
                if (sym === currentSymbol) {
                    appendTradeMarker('sell', currentPrice);
                }
                closedCount += 1;
            });

            if (simTxs.length > 300) simTxs = simTxs.slice(0, 300);

            saveSimState();
            renderSimState();
            renderEntryPriceLine();
            refreshRealtimeValuation();

            if (closedCount === 0) {
                alert('í˜„ì¬ ì‹œì„¸ë¥¼ ëª» ë¶ˆëŸ¬ì™€ ì²­ì‚°ì´ ì‹¤í–‰ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.');
                return;
            }

            if (skipped.length > 0) {
                alert(`ì´ ${closedCount}ê°œ í¬ì§€ì…˜ ì¢…ë£Œ ì™„ë£Œ (ì‹œì„¸ ë¯¸ìˆ˜ì‹  ${skipped.length}ê°œ ì œì™¸)`);
                return;
            }

            alert(`ì´ ${closedCount}ê°œ í¬ì§€ì…˜ ì¢…ë£Œ ì™„ë£Œ`);
        }

        function setSymbol(symbol) {
            currentSymbol = normalizeSymbol(symbol);
            symbolInput.value = currentSymbol;
            boardTitle.textContent = `${currentSymbol} ê²Œì‹œíŒ`;
            const url = new URL(window.location.href);
            url.searchParams.set('symbol', currentSymbol);
            history.replaceState({}, '', url.toString());
            renderPosts();
            updateChartsForSymbol(currentSymbol);
        }

        function setCategory(category) {
            currentCategory = category;
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.category === category);
            });
            renderPosts();
        }

        function renderCategories() {
            categoryTabs.innerHTML = '';
            CATEGORIES.forEach(category => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'tab';
                btn.dataset.category = category;
                btn.textContent = category;
                btn.addEventListener('click', () => setCategory(category));
                categoryTabs.appendChild(btn);
            });
            setCategory(currentCategory);
        }

        function renderPosts() {
            postList.innerHTML = '';
            const filtered = posts.filter(p => p.symbol === currentSymbol && p.category === currentCategory);
            postCount.textContent = `${filtered.length}ê±´`;
            if (filtered.length === 0) {
                postList.innerHTML = '<div class="post"><p>ì•„ì§ ê¸€ì´ ì—†ìŠµë‹ˆë‹¤.</p></div>';
                return;
            }
            filtered.forEach((post, index) => {
                const card = document.createElement('div');
                card.className = 'post';
                card.innerHTML = `
                    <h3>${post.title}</h3>
                    <div class="meta">${post.author || 'ìµëª…'} Â· ${post.date}</div>
                    <p>${post.body}</p>
                    <div class="actions">
                        <button class="ghost" data-index="${index}">ì‚­ì œ</button>
                    </div>
                `;
                postList.appendChild(card);
            });
        }

        function savePosts() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(posts));
        }

        function getModerationState() {
            try {
                return JSON.parse(localStorage.getItem(MODERATION_STATE_KEY) || '{}');
            } catch {
                return {};
            }
        }

        function saveModerationState(state) {
            localStorage.setItem(MODERATION_STATE_KEY, JSON.stringify(state || {}));
        }

        function normalizeModerationText(text) {
            return (text || '').toLowerCase().replace(/\s+/g, ' ').trim();
        }

        function normalizeCompactText(text) {
            return (text || '')
                .toLowerCase()
                .replace(/[^a-z0-9ê°€-í£]/g, '')
                .trim();
        }

        function checkCommunityViolation(text) {
            const lowered = normalizeModerationText(text);
            const compact = normalizeCompactText(text);
            if (!lowered) return null;

            const adPatterns = [
                /ë¦¬ë”©\s*ë°©|ìœ ë£Œ\s*ë°©|íšŒì›\s*ëª¨ì§‘|íˆ¬ì\s*ê¶Œìœ |í™ë³´|ê´‘ê³ |ì›ê¸ˆ\s*ë³´ì¥|ìˆ˜ìµ\s*ë³´ì¥|ìˆ˜ìµë¥ \s*ë³´ì¥/,
                /í…”ë ˆê·¸ë¨|ì˜¤í”ˆì±„íŒ…|ì¹´í†¡|ì¹´ì¹´ì˜¤í†¡|line\s*id|ë””ì— |dm\s*ì£¼ì„¸ìš”|ë¬¸ì˜\s*ì£¼ì„¸ìš”/,
                /ì±„ë„\s*ë¬¸ì˜|vip\s*ë°©|í”½\s*ê³µìœ |ê³ ìˆ˜ìµ\s*ì¸ì¦|ì¬í…Œí¬\s*ë¹„ë²•|ì¬í…Œí¬\s*ìƒë‹´/
            ];

            const contactPatterns = [
                /\b\d{2,3}[-\s]?\d{3,4}[-\s]?\d{4}\b/,
                /@[a-z0-9_.-]+\.[a-z]{2,}/,
                /t\.me\//,
                /open\.kakao\.com\//,
                /kakao\.com\//,
                /discord\.gg\//,
                /instagram\.com\//
            ];

            const sexualPatterns = [
                /ì•¼\s*ë™|ì„±\s*ì¸\s*ë°©\s*ì†¡|ë²—\s*ë°©|ëª¸\s*ìº |ì¡°ê±´\s*ë§Œë‚¨|ì„±\s*ë§¤\s*ë§¤|19\s*ê¸ˆ|ë…¸\s*ì¶œ|ì\s*ìœ„/,
                /ì›ë‚˜ì‡|ã……ã……|ì„¹\s*ìŠ¤|ì„±\s*ê´€\s*ê³„/
            ];

            const abusePatterns = [
                /ë³‘\s*ì‹ |ë¯¸\s*ì¹œ|ê°œ\s*ìƒˆ\s*ë¼|ì¢†|ì”¨\s*ë°œ|ì‹œ\s*ë°œ|êº¼\s*ì ¸|ì£½\s*ì–´|ì£½\s*ì—¬/,
                /ì¥ì• \s*ë¹„í•˜|ì¸ì¢…\s*ë¹„í•˜|ì—¬ì„±\s*ë¹„í•˜|ë‚¨ì„±\s*ë¹„í•˜|í˜ì˜¤/
            ];

            const illegalPatterns = [
                /ë§ˆ\s*ì•½|ëŒ€\s*ë§ˆ|í•„\s*ë¡œ\s*í°|ì½”\s*ì¹´\s*ì¸|ë¶ˆ\s*ë²•\s*ë„\s*ë°•|í† \s*í† |ì‚¬\s*ì„¤\s*í† \s*í† /,
                /ë¶ˆ\s*ë²•\s*ë³µ\s*ì œ|í•´\s*í‚¹|ê³„\s*ì •\s*ê±°\s*ë˜|ëŒ€\s*í¬\s*í†µ\s*ì¥/
            ];

            const scamPatterns = [
                /ì›ê¸ˆ\s*ë³´ì¥|ë¬´\s*ì¡°\s*ê±´\s*ìˆ˜\s*ìµ|ìˆ˜ìµ\s*í™•\s*ì •|100\s*%\s*ìˆ˜ìµ|ê³ \s*ìˆ˜\s*ìµ\s*ë³´\s*ì¥/,
                /ì„ \s*ì…\s*ê¸ˆ|ì…\s*ê¸ˆ\s*ìœ \s*ë„|í™˜\s*ë¶ˆ\s*ë¶ˆ\s*ê°€|ëŒ€\s*ë¦¬\s*íˆ¬\s*ì/
            ];

            const compactBlockedWords = [
                'ë¦¬ë”©ë°©', 'ìœ ë£Œë°©', 'ì˜¤í”ˆì±„íŒ…', 'í…”ë ˆê·¸ë¨', 'ì¹´ì¹´ì˜¤í†¡', 'ì›ê¸ˆë³´ì¥', 'ìˆ˜ìµë³´ì¥',
                'ì¡°ê±´ë§Œë‚¨', 'ëª¸ìº ', 'ì„±ë§¤ë§¤', 'ì•¼ë™', 'ë³‘ì‹ ', 'ê°œìƒˆë¼', 'ë§ˆì•½', 'ë¶ˆë²•ë„ë°•'
            ];

            const urlCount = (lowered.match(/https?:\/\//g) || []).length;
            if (urlCount >= 2) {
                return 'ì™¸ë¶€ ë§í¬ ê³¼ë‹¤ í¬í•¨(ìŠ¤íŒ¸ì„±)';
            }

            if (/(.)\1{9,}/.test(lowered)) {
                return 'ë„ë°°ì„± ë°˜ë³µ ë¬¸ì';
            }

            if (adPatterns.some(regex => regex.test(lowered))) {
                return 'ê°œì¸ ê´‘ê³ /í™ë³´ ë˜ëŠ” ì™¸ë¶€ ìœ ë„ì„± ë¬¸êµ¬';
            }
            if (contactPatterns.some(regex => regex.test(lowered))) {
                return 'ì—°ë½ì²˜/ì™¸ë¶€ ì±„ë„ ìœ ë„ ë¬¸êµ¬';
            }
            if (sexualPatterns.some(regex => regex.test(lowered))) {
                return 'ì„±ì Â·ìŒë€ì„± ë¬¸êµ¬';
            }
            if (abusePatterns.some(regex => regex.test(lowered))) {
                return 'ìš•ì„¤Â·í˜ì˜¤Â·í­ë ¥ì„± ë¬¸êµ¬';
            }
            if (illegalPatterns.some(regex => regex.test(lowered))) {
                return 'ë¶ˆë²• í–‰ìœ„ ê´€ë ¨ ë¬¸êµ¬';
            }
            if (scamPatterns.some(regex => regex.test(lowered))) {
                return 'ì‚¬ê¸°ì„±/ê³¼ì¥ ìˆ˜ìµ ìœ ë„ ë¬¸êµ¬';
            }
            if (compactBlockedWords.some(word => compact.includes(word))) {
                return 'ê¸ˆì§€ëœ ìš°íšŒ í‘œí˜„';
            }
            return null;
        }

        function checkPostingBan() {
            const state = getModerationState();
            const until = Number(state.bannedUntil || 0);
            if (!until || Date.now() >= until) return null;
            return new Date(until);
        }

        function registerViolation(reason) {
            const state = getModerationState();
            const strikes = Number(state.strikes || 0) + 1;
            const next = {
                strikes,
                lastReason: reason,
                lastAt: new Date().toISOString(),
                bannedUntil: state.bannedUntil || 0
            };

            if (strikes >= MODERATION_MAX_STRIKES) {
                next.bannedUntil = Date.now() + MODERATION_BAN_MS;
                next.strikes = 0;
            }

            saveModerationState(next);
            return next;
        }

        postForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const blockedUntil = checkPostingBan();
            if (blockedUntil) {
                alert(`ìš´ì˜ì •ì±… ìœ„ë°˜ ëˆ„ì ìœ¼ë¡œ ê²Œì‹œê°€ ì œí•œë˜ì—ˆìŠµë‹ˆë‹¤. í•´ì œ ì‹œê°: ${blockedUntil.toLocaleString()}`);
                return;
            }

            const title = document.getElementById('postTitle').value.trim();
            const author = document.getElementById('postAuthor').value.trim();
            const body = document.getElementById('postBody').value.trim();
            const moderationTarget = `${title}\n${author}\n${body}`;

            if (currentCategory === 'ììœ ê²Œì‹œíŒ') {
                const violation = checkCommunityViolation(moderationTarget);
                if (violation) {
                    const state = registerViolation(violation);
                    if (state.bannedUntil && Date.now() < Number(state.bannedUntil)) {
                        alert(`ê¸ˆì§€ëœ ë‚´ìš©(${violation})ì´ ê°ì§€ë˜ì–´ ê²Œì‹œê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ë°˜ë³µ ìœ„ë°˜ìœ¼ë¡œ 24ì‹œê°„ ê²Œì‹œ ì œí•œì´ ì ìš©ë©ë‹ˆë‹¤.`);
                        return;
                    }
                    const remain = MODERATION_MAX_STRIKES - Number(state.strikes || 0);
                    alert(`ê¸ˆì§€ëœ ë‚´ìš©(${violation})ì´ ê°ì§€ë˜ì–´ ê²Œì‹œê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ë°˜ë³µ ì‹œ ê²Œì‹œ ì œí•œ(ë°´)ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‚¨ì€ ê²½ê³ : ${remain}`);
                    return;
                }
            }

            const post = {
                symbol: currentSymbol,
                category: currentCategory,
                title,
                author,
                body,
                date: new Date().toLocaleString()
            };
            posts.unshift(post);
            savePosts();
            postForm.reset();
            renderPosts();
        });

        postList.addEventListener('click', (event) => {
            if (event.target.matches('button[data-index]')) {
                const index = parseInt(event.target.dataset.index, 10);
                const filtered = posts.filter(p => p.symbol === currentSymbol && p.category === currentCategory);
                const postToRemove = filtered[index];
                posts = posts.filter(p => p !== postToRemove);
                savePosts();
                renderPosts();
            }
        });

        goSymbol.addEventListener('click', () => {
            const symbol = symbolInput.value.trim();
            if (!symbol) return;
            setSymbol(symbol);
        });

        document.getElementById('exportPosts').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(posts, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'symbol-posts.json';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        });

        document.getElementById('importPosts').addEventListener('click', () => {
            document.getElementById('postImportFile').click();
        });

        document.getElementById('postImportFile').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const imported = JSON.parse(reader.result);
                    if (Array.isArray(imported)) {
                        posts = imported;
                        savePosts();
                        renderPosts();
                    }
                } catch (err) {
                    alert('ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: JSON í˜•ì‹ì„ í™•ì¸í•˜ì„¸ìš”.');
                }
            };
            reader.readAsText(file);
        });

        function initFromQuery() {
            const params = new URLSearchParams(window.location.search);
            const symbol = params.get('symbol');
            if (symbol) {
                setSymbol(symbol);
            } else {
                setSymbol(currentSymbol);
            }
        }

        document.getElementById('simMarketBuyBtn').addEventListener('click', () => executeSimTrade('market', 'buy'));
        document.getElementById('simMarketSellBtn').addEventListener('click', () => executeSimTrade('market', 'sell'));
        document.getElementById('simLimitBuyBtn').addEventListener('click', () => executeSimTrade('limit', 'buy'));
        document.getElementById('simLimitSellBtn').addEventListener('click', () => executeSimTrade('limit', 'sell'));
        document.getElementById('simCloseAllBtn').addEventListener('click', closeAllPositions);

        loadSimState();
        initLightweightChart();
        renderCategories();
        initFromQuery();
        if (realtimeQuoteTimer) clearInterval(realtimeQuoteTimer);
        realtimeQuoteTimer = setInterval(refreshRealtimeValuation, 10000);
    </script>
    <script src="./analytics.js"></script>
    <script src="./legal-consent.js"></script>
    <script src="./assistant-widget.js"></script>
</body>
</html>
